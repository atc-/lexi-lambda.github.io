<?xml version="1.0" encoding="utf-8"?> 
<rss version="2.0">
 <channel>
  <title>Alexis King's Blog: Posts tagged 'racket'</title>
  <description>Alexis King's Blog: Posts tagged 'racket'</description>
  <link>http://lexi-lambda.github.io/tags/racket.html</link>
  <lastBuildDate>Mon, 02 Jan 2017 09:16:42 UT</lastBuildDate>
  <pubDate>Mon, 02 Jan 2017 09:16:42 UT</pubDate>
  <ttl>1800</ttl>
  <item>
   <title>Rascal: a Haskell with more parentheses</title>
   <link>http://lexi-lambda.github.io/blog/2017/01/02/rascal-a-haskell-with-more-parentheses/?utm_source=racket&amp;utm_medium=RSS</link>
   <guid>urn:http-lexi-lambda-github-io:-blog-2017-01-02-rascal-a-haskell-with-more-parentheses</guid>
   <pubDate>Mon, 02 Jan 2017 09:16:42 UT</pubDate>
   <description>
&lt;p&gt;“Hey! You got your Haskell in my Racket!”&lt;/p&gt;

&lt;p&gt;“No, you got &lt;em&gt;your&lt;/em&gt; Racket in &lt;em&gt;my&lt;/em&gt; Haskell!”&lt;/p&gt;

&lt;p&gt;Welcome to the &lt;a href="https://github.com/lexi-lambda/rascal"&gt;Rascal&lt;/a&gt; programming language.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="why-rascal"&gt;Why Rascal?&lt;/h1&gt;

&lt;p&gt;Why yet &lt;em&gt;another&lt;/em&gt; programming language? Anyone who knows me knows that I already have two programming languages that I &lt;em&gt;really&lt;/em&gt; like: Haskell and Racket. Really, I think they’re both great! Each brings some things to the table that aren’t really available in any other programming language I’ve ever used.&lt;/p&gt;

&lt;p&gt;Haskell, in many ways, is a programming language that fits my mental model of how to structure programs better than any other programming language I’ve used. Some people would vehemently disagree, and it seems that there is almost certainly some heavy subjectivity in how people think about programming. I think Haskell’s model is awesome once you get used to it, though, but this blog post is not really going to try and convince you why you should care about Haskell (though that &lt;em&gt;is&lt;/em&gt; something I want to write at some point). What you &lt;em&gt;should&lt;/em&gt; understand, though, is that to me, Haskell is pretty close to what I want in a programming language.&lt;/p&gt;

&lt;p&gt;At the same time, though, Haskell has problems, and a lot of that revolves around its story for metaprogramming. “Metaprogramming” is another M word that people seem to be very afraid of, and for good reason: most metaprogramming systems are ad-hoc, unsafe, unpredictable footguns that require delicate care to use properly, and &lt;em&gt;even then&lt;/em&gt; the resulting code is brittle and difficult to understand. Haskell doesn’t suffer from this problem as much as some languages, but it isn’t perfect by any means: Haskell has at least two different metaprogramming systems (generics and Template Haskell) that are designed for different tasks, but they’re both limited in scope and both tend to be pretty complicated to use.&lt;/p&gt;

&lt;p&gt;Discussing the merits and drawbacks of Haskell’s various metaprogramming capabilities is also outside the scope of this blog post, but there’s one &lt;em&gt;fact&lt;/em&gt; that I want to bring up, which is that &lt;strong&gt;Haskell does not provide any mechanism for adding syntactic abstractions to the language&lt;/strong&gt;. What do I mean by this? Well, in order to understand what a “syntactic abstraction” is and why you should care about it, I want to shift gears a little and take a look at why Racket is so amazing.&lt;/p&gt;

&lt;h2 id="a-programmable-programming-language-theory-and-practice"&gt;A programmable programming language: theory and practice&lt;/h2&gt;

&lt;p&gt;I feel confident in saying that Racket has &lt;em&gt;the&lt;/em&gt; most advanced macro system in the world, and it is pretty much unparalleled in that space. There are many languages with powerful type systems, but Racket is more or less alone in many of the niches it occupies. Racket has a large number of innovations that I don’t know of in any other programming language, and a significant portion of them focus on making Racket a &lt;a href="http://www.ccs.neu.edu/home/matthias/manifesto/"&gt;programmable programming language, a language for building languages&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This lofty goal is backed up by decades of research, providing Racket with an unparalleled toolkit for creating languages that can communicate, be extended, and even cooperate with tooling to provide introspection and error diagnostics. Working in Haskell feels like carefully designing a mould that cleanly and precisely fits your domain, carefully carving, cutting, and whittling. In contrast, working with Racket feels like moulding your domain until it looks the way &lt;em&gt;you&lt;/em&gt; want it to look, poking and prodding at a pliable substrate. The sheer &lt;em&gt;ease&lt;/em&gt; of it all is impossible for me to convey in words, so &lt;a href="https://twitter.com/andmkent_/status/724036694773628930"&gt;you will have to see it for yourself&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;All this stuff is super abstract, though. What does it mean for practical programming, and why should you care? Well, I’m not going to try and sell you if you’re extremely skeptical, but if you’re interested, &lt;a href="https://www.youtube.com/watch?v=TfehOLha-18"&gt;I gave a talk on some of Racket’s linguistic capabilities last year called &lt;em&gt;Languages in an Afternoon&lt;/em&gt;&lt;/a&gt;. If you’re curious, give it a watch, and you might find yourself (hopefully) a little impressed. If you prefer reading, well, I have some &lt;a href="/blog/2015/12/21/adts-in-typed-racket-with-macros/"&gt;blog posts&lt;/a&gt; on this very blog that &lt;a href="/blog/2015/08/30/managing-application-configuration-with-envy/"&gt;demonstrate what Racket can do&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The basic idea, though, is that by having a simple syntax and a powerful macro system with a formalization of lexical scope, users can effectively invent entirely new language constructs as ordinary libraries, constructs that would have to be core forms in other programming languages. For example, Racket supports pattern-matching, but it isn’t built into the compiler: it’s simply implemented in the &lt;code&gt;racket/match&lt;/code&gt; module distributed with Racket. Not only is it defined in ordinary Racket code, it’s actually &lt;em&gt;extensible&lt;/em&gt;, so users can add their own pattern-matching forms that cooperate with &lt;code&gt;match&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This is the power of a macro system to produce “syntactic abstractions”, things that can transform the way a user thinks of the code they’re writing. Racket has the unique capability of making these abstractions both easy to write and watertight, so instead of being a scary tool you have to handle with extreme care, you can easily whip up a powerful, user-friendly embedded domain specific language in a matter of &lt;em&gt;minutes&lt;/em&gt;, and it’ll be safe, provide error reporting for misuse, and cooperate with existing tooling pretty much out of the box.&lt;/p&gt;

&lt;h2 id="fusing-haskell-and-racket"&gt;Fusing Haskell and Racket&lt;/h2&gt;

&lt;p&gt;So, let’s assume that we &lt;em&gt;do&lt;/em&gt; want Haskell’s strong type system and that we &lt;em&gt;also&lt;/em&gt; want a powerful metaprogramming model that permits syntactic extensions. What would that look like? Well, one way we could do it is to put one in front of the other: macro expansion is, by nature, a compile-time pass, so we could stick a macroexpander in front of the typechecker. This leads to a simple technique: first, macroexpand the program to erase the macros, then typecheck it and erase the types, then send the resulting code off to be compiled. This technique has the following properties:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;First of all, &lt;strong&gt;it’s easy to implement&lt;/strong&gt;. Racket’s macroexpander, while complex, is well-documented in academentic literature and works extremely well in practice. In fact, this strategy has already been implemented! Typed Racket, the gradually-typed sister language of Racket, expands every program before typechecking. It would be possible to effectively create a “Lisp-flavored Haskell” by using this technique, and it might not even be that hard.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;Unfortunately, there’s a huge problem with this approach: &lt;strong&gt;type information is not available at macroexpansion time&lt;/strong&gt;. This is the real dealbreaker with the “expand, then typecheck” model, since static type information is some of the most useful information possibly available to a macro writer. In an ideal world, macros should not only have access to type information, they should be able to manipulate it and metaprogram the typechecker as necessary, but if macroexpansion is a separate phase from typechecking, then that information simply doesn’t exist yet.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;For me, the second option is unacceptable. I am &lt;em&gt;not&lt;/em&gt; satisfied by a “Lisp-flavored Haskell”; I want my types and macros to be able to cooperate and communicate with each other. The trouble, though, is that solving that problem is really, really hard! For a couple years now, I’ve been wishing this ideal language existed, but I’ve had no idea how to make it actually work. Template Haskell implements a highly restricted system of interweaving typechecking and splice evaluation, but it effectively does it by running the typechecker and the splice expander alternately, splitting the source into chunks and typechecking them one at a time. This works okay for Template Haskell, but for the more powerful macro system I am looking for, it wouldn’t scale.&lt;/p&gt;

&lt;p&gt;There’s something a little bit curious, though, about the problem as I just described it. The processes of “macroexpanding the program to erase the macros” and “typechecking the program to erase the types” sound awfully similar. It seems like maybe these are two sides of the same coin, and it would be wonderful if we could encode one in terms of the other, effectively turning the two passes into a single, unified pass. Unfortunately, while this sounds great, I had no idea how to do this (and it didn’t help that I really had no idea how existing type systems were actually implemented).&lt;/p&gt;

&lt;p&gt;Fortunately, last year, Stephen Chang, Alex Knauth, and Ben Greenman put together a rather exciting paper called &lt;a href="http://www.ccs.neu.edu/home/stchang/popl2017/"&gt;&lt;em&gt;Type Systems as Macros&lt;/em&gt;&lt;/a&gt;, which does precisely what I just described, and it delivers it all in a remarkably simple and elegant presentation. The idea is to “distribute” the task of typechecking over the individual forms of the language, leveraging existing macro communication facilities avaiable in the Racket macroexpander to propagate type information as macros are expanded. To me, it was exactly what I was looking for, and I almost immediately started playing with it and seeing what I could do with it.&lt;/p&gt;

&lt;p&gt;The result is &lt;a href="https://github.com/lexi-lambda/rascal"&gt;&lt;em&gt;Rascal&lt;/em&gt;&lt;/a&gt;, a programming language built in the Racket ecosystem that attempts to implement a Haskell-like type system.&lt;/p&gt;

&lt;h1 id="a-first-peek-at-rascal"&gt;A first peek at Rascal&lt;/h1&gt;

&lt;p&gt;Rascal is a very new programming language I’ve only been working on over the past few months. It is extremely experimental, riddled with bugs, half-baked, and may turn your computer into scrambled eggs. Still, while I might not recommend that you actually &lt;em&gt;use&lt;/em&gt; it just yet, I want to try and share what it is I’m working on, since I’d bet at least a few other people will find it interesting, too.&lt;/p&gt;

&lt;p&gt;First, let me say this up front: &lt;strong&gt;Rascal is probably a lot closer to Haskell than Racket&lt;/strong&gt;. That might come as a surprise, given that Rascal has very Lisp-y syntax, it’s written in Racket, and it runs on the Racket platform, but semantically, Rascal is mostly just Haskell 98. This is important, because it may come as a surprise, given that there are so few statically typed Lisps, but there’s obviously no inherent reason that Lisps need to be dynamically typed. They just seem to have mostly evolved that way.&lt;/p&gt;

&lt;p&gt;Taking a look at a snippet of Rascal code, it’s easy to see that the language doesn’t work quite like a traditional Lisp, though:&lt;sup&gt;&lt;a href="#2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-definition" name="2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-return"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(def+ map-every-other : (forall [a] {{a -&amp;gt; a} -&amp;gt; (List a) -&amp;gt; (List a)})
  [_ nil            -&amp;gt; nil]
  [_ {x :: nil}     -&amp;gt; {x :: nil}]
  [f {x :: y :: ys} -&amp;gt; {x :: (f y) :: (map-every-other f ys)}])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a Lisp with all the goodies you would expect out of Haskell: static types, parametric polymorphism, automatically curried functions, algebraic datatypes, pattern-matching, infix operators, and of course, &lt;em&gt;typeclasses&lt;/em&gt;. Yes, with Rascal you can have your monads in all their statically dispatched glory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(data (Maybe a)
  (just a)
  nothing)

(instance (Monad Maybe)
  [join (case-lambda
          [(just (just x)) (just x)]
          [_               nothing])])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, though, this really &lt;em&gt;is&lt;/em&gt; just “Haskell with parentheses”. As alluded to above, however, Rascal is a bit more than that.&lt;/p&gt;

&lt;h2 id="core-forms-can-be-implemented-as-derived-concepts"&gt;Core forms can be implemented as derived concepts&lt;/h2&gt;

&lt;p&gt;Rascal’s type system is currently very simple, being nothing more than Hindley-Milner plus ad-hoc polymorphism in the form of typeclasses. Something interesting to note about it is that it does not implement ADTs or pattern-matching anywhere in the core! In fact, ADTs are defined as two macros &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt;, in an entirely separate module, which can be imported just like any other library.&lt;/p&gt;

&lt;p&gt;The main &lt;code&gt;rascal&lt;/code&gt; language provides ADTs by default, of course, but it would be perfectly possible to produce a &lt;code&gt;rascal/kernel&lt;/code&gt; language which does not include them at all. In this particular case, it seems unlikely that Rascal programmers would want their own implementation of ADTs, but it’s an interesting proof of concept, and it hints at other “core” features that could be implemented using macros.&lt;/p&gt;

&lt;p&gt;Simple syntactic transformations are, of course, trivially defined as macros. Haskell &lt;code&gt;do&lt;/code&gt; notation is defined as &lt;a href="https://github.com/lexi-lambda/rascal/blob/87d001a82c86fb66544d25c37ffba9be1ac63464/rascal-lib/rascal/monad.rkt#L48-L58"&gt;an eleven-line macro in &lt;code&gt;rascal/monad&lt;/code&gt;&lt;/a&gt;, and GHC’s useful &lt;code&gt;LambdaCase&lt;/code&gt; extension is also possible to implement without modifying Rascal at all. This is useful, because there are many syntactic shorthands that are extremely useful to implement, but don’t make any sense to be in GHC because they are specific to certain libraries or applications. Racket’s macro system makes those not only possible, but actually pretty easy.&lt;/p&gt;

&lt;p&gt;While the extent of what is possible to implement as derived forms remains to be seen, many useful GHC features seem quite possible to implement without touching the core language, including things like &lt;code&gt;GeneralizedNewtypeDeriving&lt;/code&gt; and other generic deriving mechanisms like &lt;code&gt;GHC.Generics&lt;/code&gt;, &lt;code&gt;DeriveGeneric&lt;/code&gt;, and &lt;code&gt;DeriveAnyClass&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id="the-language-is-not-enough"&gt;The language is not enough&lt;/h2&gt;

&lt;p&gt;No language is perfect. Most people would agree with this, but I would take it a step further: no language is even sufficient! This makes a lot of sense, given that general-purpose programming languages are designed to do &lt;em&gt;everything&lt;/em&gt;, and it’s impossible to do everything well.&lt;/p&gt;

&lt;p&gt;Haskell programmers know this, and they happily endorse the creation of embedded domain specific languages. These are fantastic, and we need more of them. Things like &lt;a href="http://hackage.haskell.org/package/servant"&gt;servant&lt;/a&gt; let me write a third of the code I might otherwise need to, and the most readable code is the code you didn’t have to write in the first place. DSLs are good.&lt;/p&gt;

&lt;p&gt;Unfortunately, building DSLs is traditionally difficult, largely in part because building embedded DSLs means figuring out a way to encode your domain into your host language of choice. Sometimes, your domain simply does not elegantly map to your host language’s syntax or semantics, and you have to come up with a compromise. This is easy to see with servant, which, while it does a remarkably good job, still has to resort to some very clever type magic to create some semblance of an API description in Haskell types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type UserAPI = "users" :&amp;gt; Get '[JSON] [User]
          :&amp;lt;|&amp;gt; "users" :&amp;gt; ReqBody '[JSON] User :&amp;gt; Post '[JSON] User
          :&amp;lt;|&amp;gt; "users" :&amp;gt; Capture "userid" Integer
                       :&amp;gt; Get '[JSON] User
          :&amp;lt;|&amp;gt; "users" :&amp;gt; Capture "userid" Integer
                       :&amp;gt; ReqBody '[JSON] User
                       :&amp;gt; Put '[JSON] User&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The above code is &lt;em&gt;remarkably&lt;/em&gt; readable for what it is, but what if we didn’t have to worry about working within the constraints of Haskell’s syntax? What if we could design a syntax that was truly the best for the job? Perhaps we would come up with something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(define-api User-API
  #:content-types [JSON]
  [GET  "users"                    =&amp;gt; (List User)]
  [POST "users"                    =&amp;gt; User -&amp;gt; User]
  [GET  "users" [userid : Integer] =&amp;gt; User]
  [PUT  "users" [userid : Integer] =&amp;gt; User -&amp;gt; User])&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This would be extremely easy to write with Racket’s macro-writing utilities, and it could even be made extensible. This could also avoid having to do the complicated typeclass trickery servant has to perform to then generate code from the above specification, since it would be much easier to just generate the necessary code directly (which still maintaining type safety).&lt;/p&gt;

&lt;p&gt;In addition to the type-level hacks that Haskell programmers often have to pull in order to make these kinds of fancy DSLs work, free monads tend to be used to create domain-specific languages. This works okay for some DSLs, but remember that when you use a free monad, you are effectively writing a &lt;em&gt;runtime interpreter&lt;/em&gt; for your language! Macros, on the other hand, are compiled, and you get ability to &lt;em&gt;compile&lt;/em&gt; your DSL to code that can be optimized by all the existing facilities of the compiler toolchain.&lt;/p&gt;

&lt;h1 id="rascal-is-embryonic"&gt;Rascal is embryonic&lt;/h1&gt;

&lt;p&gt;I’m pretty excited about Rascal. I think that it could have the potential to do some pretty interesting things, and I have some ideas in my head for how having macros in a Haskell-like language could change things. I also think that, based on what I’ve seen so far, having both macros and a Haskell-like type system could give rise to &lt;em&gt;completely&lt;/em&gt; different programming paradigms than exist in either Haskell or Racket today. My gut tells me that this is a case where the whole might actually be greater than the sum of its parts.&lt;/p&gt;

&lt;p&gt;That said, Rascal doesn’t really exist yet. Yes, &lt;a href="https://github.com/lexi-lambda/rascal"&gt;there is a GitHub repository&lt;/a&gt;, and it has some code in it that does… something. Unfortunately, the code is also currently extremely buggy, to the point of being borderline broken, and it’s also in such early stages that you can’t really do &lt;em&gt;anything&lt;/em&gt; interesting with it, aside from some tiny toy programs.&lt;/p&gt;

&lt;p&gt;As I have worked on Rascal, I’ve come to a somewhat unfortunate conclusion, which is that I really have almost zero interest in implementing type systems. I felt that way before I started the project, but I was hoping that maybe once I got into them, I would find them more interesting. Unfortunately, as much as I love working with powerful type systems (and really, I adore working with Haskell and using all the fancy features GHC provides), I find implementing the software that makes them tick completely dull.&lt;/p&gt;

&lt;p&gt;Still, I’m willing to invest the time to get something that I can use. Even so, resources for practical type system implementation are scarce. I want to thank &lt;a href="https://web.cecs.pdx.edu/~mpj/"&gt;Mark P Jones&lt;/a&gt; for his wonderful resource &lt;a href="https://web.cecs.pdx.edu/~mpj/thih/"&gt;Typing Haskell in Haskell&lt;/a&gt;, without which getting to where I am now would likely have been impossible. I also want to thank &lt;a href="http://www.stephendiehl.com"&gt;Stephen Diehl&lt;/a&gt; for his wonderful &lt;a href="http://dev.stephendiehl.com/fun/"&gt;Write You a Haskell&lt;/a&gt; series, which was also wonderfully useful to study, even if it is unfinished and doesn’t cover anything beyond ML just yet.&lt;/p&gt;

&lt;p&gt;Even with these wonderful resources, I’ve come to the realization that &lt;strong&gt;I probably can’t do all of this on my own&lt;/strong&gt;. I consider myself pretty familiar with macros and macro expanders at this point, but I don’t know much about type systems (at least not their implementation), and I could absolutely use some help. So if you’re interested in Rascal and think you might be able to pitch in, please: I would appreciate even the littlest bits of help or guidance!&lt;/p&gt;

&lt;p&gt;In the meantime, I will try to keep picking away at Rascal in the small amount of free time I currently have. Thanks, as always, to all the amazing people who have contributed to the tools I’ve been using for this project: special thanks to the authors of &lt;em&gt;Type Systems as Macros&lt;/em&gt; for their help as well as the people I mentioned just above, and also to all of the people who have built Racket and Haskell and made them what they are today. Without them, Rascal would most definitely not exist.&lt;/p&gt;

&lt;div class="footnotes"&gt;
 &lt;ol&gt;
  &lt;li id="2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-definition" class="footnote-definition"&gt;
   &lt;p&gt;Note that most of the Rascal code in this blog post probably doesn’t actually work on the current Rascal implementation. Pretty much all of it can be implemented in the current implementation, the syntax just isn’t quite as nice yet.&amp;nbsp;&lt;a href="#2017-01-02-rascal-a-haskell-with-more-parentheses-footnote-1-return"&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description></item>
  <item>
   <title>Climbing the infinite ladder of abstraction</title>
   <link>http://lexi-lambda.github.io/blog/2016/08/11/climbing-the-infinite-ladder-of-abstraction/?utm_source=racket&amp;utm_medium=RSS</link>
   <guid>urn:http-lexi-lambda-github-io:-blog-2016-08-11-climbing-the-infinite-ladder-of-abstraction</guid>
   <pubDate>Thu, 11 Aug 2016 18:03:48 UT</pubDate>
   <description>
&lt;p&gt;I started programming in elementary school.&lt;/p&gt;

&lt;p&gt;When I was young, I was fascinated by the idea of automation. I loathed doing the same repetitive task over and over again, and I always yearned for a way to &lt;a href="https://xkcd.com/974/"&gt;solve the general problem&lt;/a&gt;. When I learned about programming, I was immediately hooked: it was &lt;em&gt;so easy&lt;/em&gt; to turn repetitive tasks into automated pipelines that would free me from ever having to do the same dull, frustrating exercise ever again.&lt;/p&gt;

&lt;p&gt;Of course, one of the first things I found out once I’d started was that nothing is ever quite so simple. Before long, my solutions to eliminate repetition grew repetitive, and it became clear I spent a lot of time typing out the same things, over and over again, creating the very problem I had initially set out to destroy. It was through this that I grew interested in functions, classes, and other repetition-reducing aids, and soon enough, I discovered the wonderful world of &lt;strong&gt;abstraction&lt;/strong&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="the-brick-wall-of-inexpressiveness"&gt;The brick wall of inexpressiveness&lt;/h1&gt;

&lt;p&gt;When I started programming, I was mostly playing with ActionScript and Java, just tinkering with things and seeing what I could come up with. I had quite a lot of fun, and the joy of solving problems hooked me almost immediately, but I also ran into frustrations pretty quickly. Specifically, I started writing a lot of code that looked like this:&lt;/p&gt;

&lt;div class="brush: java"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="nf"&gt;getName&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;name&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is a bit of a cheap example, given that Java getters and setters are something of a programming language punching bag at this point, but I really did write them, and I really did get frustrated by them! I learned object-oriented design patterns, and I pored over books, forum threads, blog posts, and Stack Overflow questions about how to structure code to prevent spaghetti, but no matter how hard I tried, I kept having to type things that looked suspiciously similar to each other.&lt;/p&gt;

&lt;p&gt;It was really quite frustrating, because no matter how I approached the problem, I ended up with a boilerplate-heavy mess. The &lt;em&gt;whole reason&lt;/em&gt; I got started programming was to avoid this sort of thing, so what could I do? Well, it became increasingly obvious to me that Java had to go, and I needed to try something else. I started learning two very different programming languages, JavaScript and Objective-C, and I liked them both, for different reasons.&lt;/p&gt;

&lt;p&gt;When I learned JavaScript, I discovered the closure, the first-class function, and I was entranced by it. Through jQuery, I learned of its power to design APIs that could be fun to use, dropping the boring, “heavy” feeling that Java carried around everywhere. With Objective-C, on the other hand, I learned about the power of a more dynamic object system, something with interesting syntax and the ability to handle “message passing” at a far higher level than Java ever could.&lt;/p&gt;

&lt;p&gt;Both of these languages were flawed, as all languages are, but they opened my mind to the idea that &lt;em&gt;programming languages&lt;/em&gt; could drastically influence the way I thought about problem solving, and they set me on a quest to find the programming language that would eliminate boilerplate once and for all.&lt;/p&gt;

&lt;h1 id="discovering-lisp"&gt;Discovering Lisp&lt;/h1&gt;

&lt;p&gt;Over the next few years, I grew to appreciate JavaScript’s small, simple core, despite rather disliking its object system and poor faculties for user-friendly data modeling. I pored over its history, and I found out that its design was heavily influenced by an obscure little language called Scheme, as well as an even more obscure language called Self, and a part of me started to wonder what it would be like to incorporate those languages’ ideas without some of the compromises JavaScript had made.&lt;/p&gt;

&lt;p&gt;This idea lingered in the back of my head for a couple years, and while I tried to play with Scheme a couple times, it was simply too inaccessible for me. I was used to languages with powerful, easy to use IDEs, and when I found myself with nothing more than a command-line executable and rather scarce documentation, I was at a loss for how to begin. Even if I could do math in the REPL, where could I go from there? I’d started programming by building games, then websites. What could I possibly do with Scheme?&lt;/p&gt;

&lt;p&gt;The language (or rather, its lack of an ecosystem) proved too intimidating for me at that young age, but the idea of Lisp’s homoiconicity stuck with me. Eventually, I started to design my very own programming language, a &lt;a href="https://github.com/lexi-lambda/libsol"&gt;highly dynamic Lisp with a prototypal object system called Sol&lt;/a&gt;. I worked on it for about a year, and when I was done with it, it had a not-too-shabby complement of features: it had lambdas, macros, a fully-featured object model, and a CommonJS-esque module system, complete with the ability to dynamically import arbitrary C extensions. It was by far the largest project I’d ever worked on, and when I was done, I was pretty pleased.&lt;/p&gt;

&lt;p&gt;Unfortunately, it was also abysmally slow.&lt;/p&gt;

&lt;p&gt;I turned to a local college to find some people who could give me feedback and maybe point me in the right direction, and someone told me about another obscure programming language called &lt;a href="http://racket-lang.org"&gt;Racket&lt;/a&gt;. At about the same time, someone pointed me to a totally different language called &lt;a href="https://www.haskell.org"&gt;Haskell&lt;/a&gt;. This was uncharted territory for me, and for a while, I didn’t really explore either of those languages further. Eventually, though, I dove into them in earnest, and what I found has dramatically altered my perspective on programming since then.&lt;/p&gt;

&lt;h1 id="a-journey-into-complexity"&gt;A journey into complexity&lt;/h1&gt;

&lt;p&gt;Fast forward about three years, and today, I am employed writing Haskell, and I spend most of my free time writing Racket. These languages left a mark on me, and while I’ve learned &lt;em&gt;so much more&lt;/em&gt; since then, I find myself continually bucking the mainstream and coming back to functional programming, hygienic macros, and possibly the most powerful type system in existence in a production-ready programming language.&lt;/p&gt;

&lt;p&gt;I’ve also started realizing something else, though: &lt;strong&gt;the languages I’ve settled into are &lt;em&gt;really complicated&lt;/em&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;When I started programming, I thought about things like numbers, text, and shapes on a screen. Before long, I learned about functions, then classes, then message-passing and lambdas. I dove into macros and typeclasses, and now I speak in functors and monads, sets of scopes and internal definition contexts, and parser combinators and domain specific languages.&lt;/p&gt;

&lt;p&gt;Why?&lt;/p&gt;

&lt;p&gt;Sometimes I talk to fellow programmers, and they are horrified by the types of terms I fling around. “Why would you ever need something called a ‘monad’?” they ask, completely perplexed. “Macros are confusing,” they argue. “Being explicit is better.”&lt;/p&gt;

&lt;p&gt;Obviously, I disagree, but why? What have I given up? If my fellow programmers cannot understand what I’m writing, is it actually worth it?&lt;/p&gt;

&lt;p&gt;I’ve searched for years to find a programming language that will eliminate boilerplate, that will allow me to express my ideas succinctly and cleanly, that will let me turn hard problems into trivial ones, and I’ve discovered two completely different approaches to tackling those issues. Racket has macros, and Haskell has its fancy type system. Both of these things are lightyears ahead of where I was nearly a decade ago, writing dozens of lines of repetitive Java that ultimately did very little, but I’m still dealing with the same problems.&lt;/p&gt;

&lt;p&gt;Racket knows too little about my program—it can’t figure out what I mean based on the type of thing I’m operating on because it is (mostly) dynamically typed. I &lt;em&gt;still&lt;/em&gt; have to clarify myself and write things that feel redundant because the computer isn’t smart enough to figure out the “obvious”. Similarly, Haskell is too limiting—the compiler cannot deduce constraints I can solve in my head in seconds, and its syntax is not extensible like Racket’s is. Every day, I peer into piles upon piles of monadic computation, and really, what have I gained?&lt;/p&gt;

&lt;h2 id="improvement-but-never-mastery"&gt;Improvement, but never mastery&lt;/h2&gt;

&lt;p&gt;Like almost anything in life, programming is not really a perfectable art. There’s always some unlearned skill or undiscovered technique, and part of this potential for perpetual self-improvement is one of the things that I find so attractive about the field. That said, I this it is reasonable to say that certain languages have higher ceilings than others.&lt;/p&gt;

&lt;p&gt;For example I am pretty confident that I &lt;em&gt;get&lt;/em&gt; JavaScript. The language has lots of nooks and crannies that I don’t completely understand, but I feel pretty confident that I understand its semantics well enough to be able to grasp any piece of JavaScript code without too much incredulity. Now, that’s not to say that JavaScript is a simplistic language—far from it—but most of the ways I improve my JavaScripting abilities are learning new techniques &lt;em&gt;within&lt;/em&gt; the language, not entirely new linguistic constructs.&lt;/p&gt;

&lt;p&gt;On the other hand, languages like Haskell and Racket tend to blur the line. I feel like I have a good grasp of Haskell’s core, but do I have a good intuition for laziness? Do I completely grok type families? What about &lt;code&gt;TypeInType&lt;/code&gt;? Ultimately, I have to come to the conclusion that I do not fully understand Haskell, much less a lot of the advanced category theory that composes some of its most powerful libraries. Racket manages to blur the line between language and library even further, and while I consider myself a decent Racketeer, I absolutely do &lt;em&gt;not&lt;/em&gt; have a good grasp on all the intricacies of Racket’s macro system.&lt;/p&gt;

&lt;p&gt;This is especially obvious to me at work, given that I write Haskell in a team setting. Just like back when I was writing Java, I end up with solutions that don’t satisfy me, and I reach for increasingly powerful constructs to help alleviate my qualms. Sometimes, I find myself cracking out &lt;code&gt;DataKinds&lt;/code&gt;, and it might even help my problem, but there’s a cost: my coworkers are sometimes confused.&lt;/p&gt;

&lt;p&gt;Every time I climb to the next rung on the ladder of abstraction, those only a couple rungs below me (even if we’re all hundreds of rungs up!) find themselves perplexed. In the worst case, people may even blame their confusion on their own inadequacy or lack of skill. This is &lt;em&gt;terrible&lt;/em&gt;, especially when I know that, by the time they’ve caught up, I’ll be off playing with some new toy: comonads or type families or classy lenses. The cycle continues, and nobody is ever truly satisfied—I always want to find a new abstraction that will make things simpler, and those just a couple steps behind me struggle to keep up.&lt;/p&gt;

&lt;p&gt;Of course, I experience it from the opposite perspective just as often: I delve into Edward Kmett’s fancier libraries or Phil Freeman’s blog posts about category theory, and I recognize that I am rather lost. Sometimes, I find myself understanding things, but just as often, I cannot wrap my head around the concepts being discussed. I may figure them out eventually, sure, but by then everyone else has moved on to even &lt;em&gt;more&lt;/em&gt; advanced things, and still, none of them truly solve my problems.&lt;/p&gt;

&lt;h1 id="ultimately-it-all-has-at-least-a-little-value"&gt;Ultimately, it all has (at least a little) value&lt;/h1&gt;

&lt;p&gt;It would be nice to think about all that and say, well, “Let’s finally break the cycle. Let’s stop deluding ourselves into thinking our solutions to our self-made problems are actually solving anything.” It would be great if I could tell myself that, but I unfortunately really can’t.&lt;/p&gt;

&lt;p&gt;The scariest part of all is that I think it’s completely worthwhile.&lt;/p&gt;

&lt;p&gt;So much of these more and more complicated abstractions are trying to do the same basic thing: come up with a better way of modeling the problem. In some sense, that’s all programming really is, modeling a domain in a way that can be leveraged by a digital computer. Our increasingly complicated DSLs &lt;em&gt;seem&lt;/em&gt; unnecessarily complicated, they &lt;em&gt;seem&lt;/em&gt; increasingly removed from reality, but that’s only because we’re getting better at creating languages that are closer to our domains without the baggage of preconceptions that came before us.&lt;/p&gt;

&lt;p&gt;The downside is that, without an understanding of those preconceptions, a lot of what we come up with seems like patent gibberish to those unaware of our languages’ history.&lt;/p&gt;

&lt;p&gt;Most programmers, even those who have never seen BASIC before, can figure out what this snippet does:&lt;/p&gt;

&lt;div class="brush: BASIC"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nl"&gt;10&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;INPUT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"What is your name: "&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;U$&lt;/span&gt;
&lt;span class="nl"&gt;20&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kr"&gt;PRINT&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s2"&gt;"Hello "&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="vg"&gt;U$&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;On the other hand, very few would probably understand this one:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;-- | A class for categories.&lt;/span&gt;
&lt;span class="c1"&gt;--   id and (.) must form a monoid.&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="kt"&gt;Category&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="kr"&gt;where&lt;/span&gt;
    &lt;span class="c1"&gt;-- | the identity morphism&lt;/span&gt;
    &lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;

    &lt;span class="c1"&gt;-- | morphism composition&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;::&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="ow"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;cat&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Yet very few new programs are being written in BASIC, and lots are being written in Haskell.&lt;/p&gt;

&lt;p&gt;Even one of the most popular, fastest-growing programming languages in the world, JavaScript, a language considered relatively accessible compared to things like Haskell, would likely be incomprehensible to a programmer not familiar with its syntax:&lt;/p&gt;

&lt;div class="brush: js"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;export&lt;/span&gt; &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;composeWithProps&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;curry&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;parentProps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kr"&gt;const&lt;/span&gt; &lt;span class="nx"&gt;composed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;childProps&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class="nx"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;parentProps&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;createElement&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;omit&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;children&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="nx"&gt;childProps&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="nx"&gt;childProps&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;children&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
  &lt;span class="c1"&gt;// give the composed component a pretty display name for debugging&lt;/span&gt;
  &lt;span class="nx"&gt;composed&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;displayName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="sb"&gt;`Composed(&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;getDisplayName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;, &lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nx"&gt;getDisplayName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="sb"&gt;)`&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;composed&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Moving towards increasingly specialized syntaxes is not inherently bad—it can often be indicative of a more streamlined, domain-specific way of thinking—but while it may dramatically increase the productivity of a seasoned programmer, it can be nothing short of baffling to a newcomer.&lt;/p&gt;

&lt;p&gt;That, specifically, is the crux of my fear: are we always aware of who we are optimizing for? I do not have a moral problem with writing code to optimize concision for seasoned programmers; after all, brevity is one of the primary ways code is made more readable (verbosity is the enemy of understanding). However, when that concision comes at the cost of beginners’ understanding, the picture becomes a bit more grey. It is not wrong to write things that are highly optimized for one’s own knowledge and understanding, and establishing a group of such people can make for an &lt;em&gt;extremely&lt;/em&gt; productive team. It’s just also important to understand that others will likely be confused, and without being willing to invest the time and money into education, smart, diligent people will still fail to grasp the concepts, and they will likely be wholly uninterested in them.&lt;/p&gt;

&lt;h2 id="reactionary-anti-intellectualism-and-the-search-for-moderation"&gt;Reactionary anti-intellectualism and the search for moderation&lt;/h2&gt;

&lt;p&gt;I have noticed lately that people close to my circles have started regularly slinging insults at people who work in highly specialized notation. Math, including things like category and type theory, has become an especially acceptable punching bag. &lt;a href="https://twitter.com/lexi_lambda/status/763111451691134976"&gt;I recently tweeted a picture of some rather dense mathematics from a paper I’d read&lt;/a&gt;, and I was frankly disturbed at some of the vitriolic responses. Academia is sometimes described as “masturbatory”, and honestly, that is both offensive and hypocritical.&lt;/p&gt;

&lt;p&gt;Mathematical notation is not perfect, no more than dense Haskell, heavily metaprogrammed Ruby, or IIFE-packed JavaScript. Still, it serves a purpose, and sometimes spelling things out is neither practically feasible nor a theoretical improvement. Programmers would not take kindly to being asked to write all their code out as prose, nor would they like being told that using higher-order functions like &lt;code&gt;map&lt;/code&gt; should be banned because they are too confusing and not immediately self-explanatory.&lt;/p&gt;

&lt;p&gt;I am glad that people are focusing on usability and accessibility more than ever, and I think that’s one of the areas I’m the most interested in. I want to get the best of both worlds: I aim to write code in a highly concise, precise style, but I try and produce intuitive interfaces with human-readable errors upon failure. To me, a user-hostile yet technically functional library is a buggy one, and I would happily file a bug report about a confusing API or error message.&lt;/p&gt;

&lt;p&gt;Abstraction is what seems to make programming possible, and indeed, it’s what makes most modern &lt;em&gt;technology&lt;/em&gt; possible. It’s what allows people to drive a car without knowing how an internal combustion engine works, and it’s what allows people to browse the web without having a deep understanding of internet protocol. In programming, abstraction serves a similar purpose. Of course, just like all tools, abstractions can have rather different goals: the average user will not pick up Photoshop in a day, but a power user is not going to be satisfied with Paint.&lt;/p&gt;

&lt;p&gt;Programmers are professionals, and we work in a technical domain. I am absolutely of the belief that programming, like any other field, is not always about what comes easiest: sometimes it’s important to sit down and study for a while to grok a particularly complicated concept, and other times, it’s simply important to learn by trying, failing, and asking questions. I strive to find that blend of accessible, concise, and robust, and just like everything else, that target shifts depending on the situation and people I’m working with.&lt;/p&gt;

&lt;p&gt;I honestly don’t know if Racket and Haskell are worth their costs in complexity. At the end of the day, maybe what really matters is writing simple, consistent things that other people can understand. I really hope that there is a place for more powerful languages within a team, but there’s something to be said about which languages tend to get the most popular.&lt;/p&gt;

&lt;p&gt;Ultimately, though, I am just trying to be aware of the tradeoffs I’m making, the benefits I’m getting, and the impact on those I’m working with. I will continue to search for abstractions that can better fit my needs, and I am sure I will keep on climbing the ladder of abstraction for years to come—I just really hope I’m not wasting my time.&lt;/p&gt;</description></item>
  <item>
   <title>Simple, safe multimethods in Racket</title>
   <link>http://lexi-lambda.github.io/blog/2016/02/18/simple-safe-multimethods-in-racket/?utm_source=racket&amp;utm_medium=RSS</link>
   <guid>urn:http-lexi-lambda-github-io:-blog-2016-02-18-simple-safe-multimethods-in-racket</guid>
   <pubDate>Thu, 18 Feb 2016 18:48:32 UT</pubDate>
   <description>
&lt;p&gt;Racket ships with &lt;code&gt;racket/generic&lt;/code&gt;, a system for defining &lt;em&gt;generic methods&lt;/em&gt;, functions that work differently depending on what sort of value they are supplied. I have made heavy use of this feature in my collections library, and it has worked well for my needs, but that system does have a bit of a limitation: it only supports &lt;em&gt;single dispatch&lt;/em&gt;. Method implementations may only be chosen based on a single argument, so multiple dispatch is impossible.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="motivating-multiple-dispatch"&gt;Motivating multiple dispatch&lt;/h1&gt;

&lt;p&gt;What is multiple dispatch and why is it necessary? Well, in most cases, it &lt;em&gt;isn’t&lt;/em&gt; necessary at all. &lt;a href="http://dl.acm.org/citation.cfm?doid=1449764.1449808"&gt;It has been shown that multiple dispatch is much rarer than single dispatch in practice.&lt;/a&gt; However, when actually needed, having multiple dispatch in the toolbox is a valuable asset.&lt;/p&gt;

&lt;p&gt;A classic example of multiple dispatch is multiplication over both scalars and vectors. Ideally, all of the following operations should work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2 × 3 = 6
2 × ⟨3, 4⟩ = ⟨6, 8⟩
⟨3, 4⟩ × 2 = ⟨6, 8⟩&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In practice, most languages do not support such flexible dispatch rules without fairly complicated branching constructs to handle each permutation of input types. Furthermore, since most languages only support single dispatch (such as most object-oriented languages), it is nearly impossible to add support for a new combination of types to an existing method.&lt;/p&gt;

&lt;p&gt;To illustrate the above, even if a language supported operator overloading &lt;em&gt;and&lt;/em&gt; it included a &lt;code&gt;Vector&lt;/code&gt; class that overloaded multiplication to properly work with numbers and vectors, it might not implement matrix multiplication. If a user defines a &lt;code&gt;Matrix&lt;/code&gt; class, they may overload &lt;em&gt;its&lt;/em&gt; multiplication to support numbers, vectors, and matrices, but it is impossible to extend the multiplication implementation for the &lt;code&gt;Vector&lt;/code&gt; class. That method is now completely set in stone, unless it is edited directly (and the programmer may not have access to &lt;code&gt;Vector&lt;/code&gt;’s implementation).&lt;/p&gt;

&lt;p&gt;Multiple dispatch solves all of these problems. Rather than specify implementations of functions for singular types, it is possible to specify implementations for sets of types. In the above example, a programmer would be able to define a new function that operates on &lt;code&gt;Vector&lt;/code&gt; and &lt;code&gt;Matrix&lt;/code&gt; arguments. Since each definition does not “belong” to any given type, extending this set of operations is trivial.&lt;/p&gt;

&lt;h1 id="multiple-dispatch-in-racket"&gt;Multiple dispatch in Racket&lt;/h1&gt;

&lt;p&gt;This blog post is somewhat long and technical, so before proceeding any further, I want to show some real code that actually works so you can get a feel for what I’m talking about. As a proof-of-concept, I have created &lt;a href="https://github.com/lexi-lambda/racket-multimethod"&gt;a very simple implementation of multiple dispatch in Racket&lt;/a&gt;. The above example would look like this in Racket using my module:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._require))" style="color: inherit"&gt;require&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;multimethod&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._provide))" style="color: inherit"&gt;provide&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;mul&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._struct-out))" style="color: inherit"&gt;struct-out&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._struct-out))" style="color: inherit"&gt;struct-out&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" style="color: inherit"&gt;struct&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" style="color: inherit"&gt;struct&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vals&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-generic&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))" style="color: inherit"&gt;*&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._map))" style="color: inherit"&gt;map&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/procedures.html#(def._((lib._racket/function..rkt)._curry))" style="color: inherit"&gt;curry&lt;/a&gt;&lt;/span&gt; &lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))" style="color: inherit"&gt;*&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec-vals&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Pardon the somewhat clunky syntax, but the functionality is there. Using the above code works as expected:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; (mul (num 2) (num 3))
(num 6)
&amp;gt; (mul (num 2) (vec '(3 4)))
(vec '(6 8))
&amp;gt; (mul (vec '(3 4)) (num 2))
(vec '(6 8))&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Making the above snippet work is not particularly hard. In fact, it’s likely that most competent Racketeers could do it without much thought. However, there’s a tiny bit more going on behind the scenes than it may seem.&lt;/p&gt;

&lt;h1 id="the-problem-with-multiple-dispatch"&gt;The problem with multiple dispatch&lt;/h1&gt;

&lt;p&gt;The single-dispatch design limitation of &lt;code&gt;racket/generic&lt;/code&gt; comes directly from a desire to avoid what has been described as “spooky action at a distance”, a problem that is prevalent in many systems that support methods with multiple dispatch (aka &lt;em&gt;multimethods&lt;/em&gt;). Specifically, the issue arises when new method implementations are defined for existing datatypes, which can have far-reaching effects throughout a program because the method table is global state. Both CLOS and Clojure suffer from this shortcoming.&lt;/p&gt;

&lt;p&gt;Interestingly, Haskell with multi-parameter typeclasses (a nonstandard but highly useful extension) makes it quite trivial to create constructs similar to multiple dispatch (though the overload resolution is done at compile-time). The similarities are significant: Haskell &lt;em&gt;also&lt;/em&gt; suffers from the possibility of a certain sort of “spooky action”. However, Haskell’s static typing and resolution allows the compiler to catch these potential issues, known as “orphan instances”, at compile time. Even though Racket does not support the same sort of static typing, the same idea can be used to keep multiple dispatch safe using the macro system.&lt;/p&gt;

&lt;h1 id="safe-dynamically-typed-multiple-dispatch"&gt;Safe, dynamically-typed multiple dispatch&lt;/h1&gt;

&lt;p&gt;In order to make multiple dispatch safe, we first need to determine exactly what is unsafe. Haskell has rules for determining what constitutes an “orphan instance”, and these rules are equally applicable for determining dangerous multimethod implementations. Specifically, a definition can be considered unsafe if &lt;em&gt;both&lt;/em&gt; of the following conditions are true:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;The multimethod that is being implemented was declared in a different module from the implementation.&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;All&lt;/em&gt; of the types used for dispatch in the multimethod instance were declared in a different module from the implementation.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Conversely, a multimethod implementation is safe if &lt;em&gt;either&lt;/em&gt; of the following conditions are true:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;The multimethod that is being implemented is declared in the same module as the implementation.&lt;/li&gt;
 &lt;li&gt;&lt;em&gt;Any&lt;/em&gt; of the types used for dispatch in the multimethod instance are declared in the same module as the implementation.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Why do these two rules provide a strong enough guarantee to eliminate the dangers created by global state? Well, to understand that, we need to understand what can go wrong if these rules are ignored.&lt;/p&gt;

&lt;h2 id="multimethods-and-dangerous-instances"&gt;Multimethods and dangerous instances&lt;/h2&gt;

&lt;p&gt;What exactly is this dangerous-sounding “spooky action”, and what causes it? Well, the trouble stems from the side-effectful nature of multimethod instance definitions. Consider the Racket module from earlier, which defines multiplication instances for scalars and vectors:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._provide))" style="color: inherit"&gt;provide&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;mul&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._struct-out))" style="color: inherit"&gt;struct-out&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._struct-out))" style="color: inherit"&gt;struct-out&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" style="color: inherit"&gt;struct&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" style="color: inherit"&gt;struct&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vals&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-generic&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))" style="color: inherit"&gt;*&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._map))" style="color: inherit"&gt;map&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/procedures.html#(def._((lib._racket/function..rkt)._curry))" style="color: inherit"&gt;curry&lt;/a&gt;&lt;/span&gt; &lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))" style="color: inherit"&gt;*&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num-val&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec-vals&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Note that there is not actually a &lt;code&gt;(mul vec vec)&lt;/code&gt; implementation. This is intentional: there are &lt;em&gt;two&lt;/em&gt; ways to take the product of two vectors, so no default implementation is provided. However, it is possible that another module might desire an instance for &lt;code&gt;mul&lt;/code&gt; that takes the dot product, and the programmer might write the following definition:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mul&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt; &lt;span class="n"&gt;vec&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/list..rkt)._foldl))" style="color: inherit"&gt;foldl&lt;/a&gt;&lt;/span&gt; &lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._map))" style="color: inherit"&gt;map&lt;/a&gt;&lt;/span&gt; &lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))" style="color: inherit"&gt;*&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec-vals&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vec-vals&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, there is something fishy about the above definition: it doesn’t need to be exported with &lt;code&gt;provide&lt;/code&gt; to work! Since instances don’t create new bindings, they only add dispatch options, they don’t ever need to &lt;code&gt;provide&lt;/code&gt; anything. This is problematic, though: it means that a program could continue to happily compile &lt;em&gt;even if&lt;/em&gt; the module containing the dot product instance was never loaded with &lt;code&gt;require&lt;/code&gt;, but an attempt to multiply two vectors would fail at runtime, claiming that there was no &lt;code&gt;(mul vec vec)&lt;/code&gt; implementation. This drastic change of behavior violates Racket programmers’ assumptions about the guarantees made by modules (&lt;code&gt;require&lt;/code&gt; should not cause any side-effects if the module’s bindings are not used).&lt;/p&gt;

&lt;p&gt;Of course, while this seems potentially unexpected, it is workable: just be careful to &lt;code&gt;require&lt;/code&gt; modules containing instances. Unfortunately, it gets much worse—what if a different library defines &lt;em&gt;its own&lt;/em&gt; &lt;code&gt;(mul vec vec)&lt;/code&gt; instance? What if that instance takes the cross product instead? That library may function entirely properly on its own, but when loaded alongside the program that defines a dot product instance, it is impossible to determine which instance should be used where. Because &lt;code&gt;define-instance&lt;/code&gt; operates by modifying the aforementioned global state, the implementations clash, and the two systems &lt;em&gt;cannot&lt;/em&gt; continue to operate together as written.&lt;/p&gt;

&lt;p&gt;This is pretty bad. Defining extra instances is a reasonable use-case for multiple dispatch, but if these instances can break &lt;em&gt;third-party code&lt;/em&gt;, how can they be trusted? This sort of problem can make multiple dispatch difficult to reason about and even more difficult to trust.&lt;/p&gt;

&lt;h2 id="what-determines-safety"&gt;What determines safety?&lt;/h2&gt;

&lt;p&gt;With those problems in mind, we can turn back to the two rules for &lt;em&gt;safe&lt;/em&gt; multiple dispatch. How do they prevent the above issues? Well, let’s take them one at a time.&lt;/p&gt;

&lt;p&gt;Remember that an instance can be unequivocally determined to be safe if either of the two conditions are true, so we can consider them entirely independently. The first one is simple—an instance is safe if the following condition holds:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;The multimethod that is being implemented is declared in the same module as the implementation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;This one is pretty obvious. It is impossible to create a “bad” instance of a method declared in the same module because it is impossible to import the method without also bringing in the instance. Furthermore, a conflicting instance cannot be defined at the place where the types themselves are defined because that would require a circular module dependency, which Racket does not permit.&lt;/p&gt;

&lt;p&gt;With the above explanation in mind, the second condition should make sense, too:&lt;/p&gt;

&lt;blockquote&gt;
 &lt;p&gt;&lt;em&gt;Any&lt;/em&gt; of the types used for dispatch in the multimethod instance are declared in the same module as the implementation.&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The same argument for the first point holds for the second, but with the parties swapped. Again, it is impossible to use the instance without somehow requiring the module that defines the datatype itself, so the instance would always be required, anyway. The most interesting aspect of this condition is that it demonstrates that instances can be defined for existing datatypes (that are defined in other modules) just so long as &lt;em&gt;at least one&lt;/em&gt; of the datatypes is defined in the same module. This continues to permit the important use-case of extending the interfaces of existing types.&lt;/p&gt;

&lt;h2 id="encoding-the-safety-rules-into-rackets-macro-system"&gt;Encoding the safety rules into Racket’s macro system&lt;/h2&gt;

&lt;p&gt;In order to keep track of which methods and instances are defined where, I leveraged a technique based on the one &lt;a href="http://www.ccs.neu.edu/racket/pubs/scheme2007-ctf.pdf"&gt;used by Typed Racket to keep track of whether or not a typed identifier is used in a typed or untyped context&lt;/a&gt;. However, instead of using a simple mutable boolean flag, I used a mutable &lt;a href="http://docs.racket-lang.org/syntax/syntax-helpers.html#%28tech._identifier._set%29"&gt;free identifier set&lt;/a&gt;, which keeps track of the identifiers within a given module that should be considered “privileged”.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket/base&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._require))" style="color: inherit"&gt;require&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;syntax/id-set&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._provide))" style="color: inherit"&gt;provide&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;mark-id-as-privileged!&lt;/span&gt;
         &lt;span class="n"&gt;id-privileged?&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;privileged-ids&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mutable-free-id-set&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mark-id-as-privileged!&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#(form._((lib._syntax/parse..rkt)._id))" style="color: inherit"&gt;id&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;free-id-set-add!&lt;/span&gt; &lt;span class="n"&gt;privileged-ids&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#(form._((lib._syntax/parse..rkt)._id))" style="color: inherit"&gt;id&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#(form._((lib._syntax/parse..rkt)._id))" style="color: inherit"&gt;id&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;free-id-set-member?&lt;/span&gt; &lt;span class="n"&gt;privileged-ids&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#(form._((lib._syntax/parse..rkt)._id))" style="color: inherit"&gt;id&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Making this work with &lt;code&gt;define-generic&lt;/code&gt; is obvious: just invoke &lt;code&gt;mark-id-as-privileged!&lt;/code&gt; on the method name to note that the method is “privileged” in the scope of the current module. Keeping track of privileged structs is similarly straightforward, though it is a little more devious: the &lt;code&gt;multimethod&lt;/code&gt; module provides a custom &lt;code&gt;struct&lt;/code&gt; macro that just expands to &lt;code&gt;struct&lt;/code&gt; from &lt;code&gt;racket/base&lt;/code&gt;, but adds privilege information.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;define-instance&lt;/code&gt; macro does all the heavy lifting to ensure that only privileged identifiers can be used in instance definitions. A simple check for the identifier annotations is performed before proceeding with macro expansion:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/when_unless.html#(form._((lib._racket/private/letstx-scheme..rkt)._unless))" style="color: inherit"&gt;unless&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._or))" style="color: inherit"&gt;or&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;privileged?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._ormap))" style="color: inherit"&gt;ormap&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assert-privileged-struct!&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._first))" style="color: inherit"&gt;first&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;When the privilege checks fail, an error is raised:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assert-privileged-struct!&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#(form._((lib._syntax/parse..rkt)._id))" style="color: inherit"&gt;id&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/when_unless.html#(form._((lib._racket/private/letstx-scheme..rkt)._unless))" style="color: inherit"&gt;unless&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#(form._((lib._syntax/parse..rkt)._id))" style="color: inherit"&gt;id&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/exns.html#(def._((quote._~23~25kernel)._raise-syntax-error))" style="color: inherit"&gt;raise-syntax-error&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="ss"&gt;define-instance&lt;/span&gt;
                        &lt;span class="s2"&gt;"expected name of &lt;a href="http://docs.racket-lang.org/reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" style="color: inherit"&gt;struct&lt;/a&gt; defined in current module"&lt;/span&gt;
                        &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#(form._((lib._syntax/parse..rkt)._id))" style="color: inherit"&gt;id&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With the above safeguards in place, the dangerous dot product implementation from above &lt;strong&gt;would not be allowed&lt;/strong&gt;. The checks manage to encode both of the safety rules into the macro system such that invalid instances will fail &lt;em&gt;at compile time&lt;/em&gt;, preventing dangerous uses of multimethods from ever slipping by unnoticed.&lt;/p&gt;

&lt;h2 id="actually-implementing-multiple-dispatch"&gt;Actually implementing multiple dispatch&lt;/h2&gt;

&lt;p&gt;The rest of the multimethod implementation is relatively straightforward and is not even particularly robust. If anything, it is the bare minimum of what would be needed to allow the safety mechanisms above to work. Lots of features that would likely be needed in a real implementation are not included, and graceful error handling is largely ignored.&lt;/p&gt;

&lt;p&gt;Multimethods themselves are implemented as Racket &lt;a href="http://docs.racket-lang.org/guide/proc-macros.html#%28tech._transformer._binding%29"&gt;transformer bindings&lt;/a&gt; containing custom data, including a reference to the multimethod’s arity and dispatch table. The custom datatype includes a &lt;code&gt;prop:procedure&lt;/code&gt; structure type property, which allows such bindings to also function as macros. The macro procedure expands to an operation that looks up the proper instance to use in the multimethod’s dispatch table and invokes it with the supplied arguments.&lt;/p&gt;

&lt;p&gt;The relevant code for defining multimethods is reproduced below:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin-for-syntax))" style="color: inherit"&gt;begin-for-syntax&lt;/a&gt;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" style="color: inherit"&gt;struct&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;multimethod&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arity&lt;/span&gt; &lt;span class="n"&gt;dispatch-table&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="kd"&gt;#:property&lt;/span&gt; &lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/procedures.html#(def._((lib._racket/private/base..rkt)._prop~3aprocedure))" style="color: inherit"&gt;prop:procedure&lt;/a&gt;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._~ce~bb))" style="color: inherit"&gt;λ&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#(form._((lib._syntax/parse..rkt)._syntax-parse))" style="color: inherit"&gt;syntax-parse&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;stx&lt;/span&gt;
        &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;apply-multimethod&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))" style="color: inherit"&gt;list&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;
         &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._~ce~bb))" style="color: inherit"&gt;λ&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;apply-multimethod&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;))]))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit"&gt;define-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;define-generic&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#(form._((lib._syntax/parse..rkt)._syntax-parser))" style="color: inherit"&gt;syntax-parser&lt;/a&gt;&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt).__))" style="color: inherit"&gt;_&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method:id&lt;/span&gt; &lt;span class="n"&gt;arg:id&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html#(form._((lib._syntax/parse..rkt)._......+))" style="color: inherit"&gt;...+&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._with-syntax))" style="color: inherit"&gt;with-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;arity&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._length))" style="color: inherit"&gt;length&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
                   &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;dispatch-table&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/reference/syntax-util.html#(def._((lib._racket/syntax..rkt)._generate-temporary))" style="color: inherit"&gt;generate-temporary&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mark-id-as-privileged!&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
       &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))" style="color: inherit"&gt;begin&lt;/a&gt;&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;dispatch-table&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/hashtables.html#(def._((quote._~23~25kernel)._make-hash))" style="color: inherit"&gt;make-hash&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit"&gt;define-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;multimethod&lt;/span&gt; &lt;span class="n"&gt;arity&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="n"&gt;dispatch-table&lt;/span&gt;&lt;span class="p"&gt;))))]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The dispatch tables are implemented entirely in terms of Racket’s structure types, so while they can be defined on arbitrary structure types (including ones defined in the Racket standard library), they &lt;em&gt;cannot&lt;/em&gt; be defined on primitives such as pairs or vectors. Implementations are registered in the dispatch table using the compile-time information associated with structs’ transformer bindings, and the same information is retrieved from struct instances at runtime to look up the proper implementation to call. Notably, this only works if the struct is &lt;code&gt;#:transparent&lt;/code&gt;, or more generally and accurately, if the calling code has access to the struct’s inspector. All structs defined by the &lt;code&gt;struct&lt;/code&gt; form from the &lt;code&gt;multimethod&lt;/code&gt; module are automatically marked as &lt;code&gt;#:transparent&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The following code implements defining multimethod instances:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin-for-syntax))" style="color: inherit"&gt;begin-for-syntax&lt;/a&gt;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assert-privileged-struct!&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#(form._((lib._syntax/parse..rkt)._id))" style="color: inherit"&gt;id&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/when_unless.html#(form._((lib._racket/private/letstx-scheme..rkt)._unless))" style="color: inherit"&gt;unless&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#(form._((lib._syntax/parse..rkt)._id))" style="color: inherit"&gt;id&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/exns.html#(def._((quote._~23~25kernel)._raise-syntax-error))" style="color: inherit"&gt;raise-syntax-error&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="ss"&gt;define-instance&lt;/span&gt;
                          &lt;span class="s2"&gt;"expected name of &lt;a href="http://docs.racket-lang.org/reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" style="color: inherit"&gt;struct&lt;/a&gt; defined in current module"&lt;/span&gt;
                          &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Library_Syntax_Classes_and_Literal_Sets.html#(form._((lib._syntax/parse..rkt)._id))" style="color: inherit"&gt;id&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit"&gt;define-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;define-instance&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#(form._((lib._syntax/parse..rkt)._syntax-parser))" style="color: inherit"&gt;syntax-parser&lt;/a&gt;&lt;/span&gt;
    &lt;span class="c1"&gt;; standard (define (proc ...) ...) shorthand&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt).__))" style="color: inherit"&gt;_&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;type:id&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html#(form._((lib._syntax/parse..rkt)._......+))" style="color: inherit"&gt;...+&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;body:expr&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html#(form._((lib._syntax/parse..rkt)._......+))" style="color: inherit"&gt;...+&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-instance&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._~ce~bb))" style="color: inherit"&gt;λ&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="n"&gt;body&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="c1"&gt;; full (define proc lambda-expr) notation&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt).__))" style="color: inherit"&gt;_&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt; &lt;span class="n"&gt;type:id&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html#(form._((lib._syntax/parse..rkt)._......+))" style="color: inherit"&gt;...+&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;proc:expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let*))" style="color: inherit"&gt;let*&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;multimethod&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#(def._((quote._~23~25kernel)._syntax-local-value))" style="color: inherit"&gt;syntax-local-value&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;privileged?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/when_unless.html#(form._((lib._racket/private/letstx-scheme..rkt)._unless))" style="color: inherit"&gt;unless&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._or))" style="color: inherit"&gt;or&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;privileged?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._ormap))" style="color: inherit"&gt;ormap&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;id-privileged?&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;assert-privileged-struct!&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._first))" style="color: inherit"&gt;first&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._with-syntax))" style="color: inherit"&gt;with-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;dispatch-table&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;multimethod-dispatch-table&lt;/span&gt; &lt;span class="n"&gt;multimethod&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
                     &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;struct-type-id&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._map))" style="color: inherit"&gt;map&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/procedures.html#(def._((lib._racket/private/list..rkt)._compose1))" style="color: inherit"&gt;compose1&lt;/a&gt;&lt;/span&gt; &lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/list..rkt)._first))" style="color: inherit"&gt;first&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/reference/structinfo.html#(def._((lib._racket/struct-info..rkt)._extract-struct-info))" style="color: inherit"&gt;extract-struct-info&lt;/a&gt;&lt;/span&gt; &lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/stxtrans.html#(def._((quote._~23~25kernel)._syntax-local-value))" style="color: inherit"&gt;syntax-local-value&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                                                &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
         &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit"&gt;let&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;struct-types&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))" style="color: inherit"&gt;list&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;struct-type-id&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
             &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/hashtables.html#(def._((quote._~23~25kernel)._hash-set!))" style="color: inherit"&gt;hash-set!&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;dispatch-table&lt;/span&gt; &lt;span class="n"&gt;struct-types&lt;/span&gt; &lt;span class="n"&gt;proc&lt;/span&gt;&lt;span class="p"&gt;))))]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The resulting implementation is a useful, if certainly incomplete implementation of multimethods in Racket that does not sacrifice the safety provided by &lt;code&gt;racket/generic&lt;/code&gt;’s single-dispatch approach.&lt;/p&gt;

&lt;h1 id="related-work-advantages-and-disadvantages-and-areas-for-future-improvement"&gt;Related work, advantages and disadvantages, and areas for future improvement&lt;/h1&gt;

&lt;p&gt;As previously mentioned, this implementation of multiple dispatch was inspired by the types of APIs offered by CLOS and Clojure while also maintaining the safety of &lt;code&gt;racket/generic&lt;/code&gt;. The inspiration for the safety rules came from GHC’s detection of orphan instances. Although most of the ideas presented above exist in other places, I am unsure if the concept of safety checking has been used before in any dynamically-typed programming languages.&lt;/p&gt;

&lt;p&gt;The primary advantage offered over Racket’s existing generics system is obvious: multiple dispatch. Furthermore, this system can supersede many uses of &lt;code&gt;racket/generic&lt;/code&gt; simply by dispatching on a single type. However, the current implementation does &lt;em&gt;not&lt;/em&gt; support all of the features of &lt;code&gt;racket/generic&lt;/code&gt;, such as supporting non-structure types and allowing fallback implementations. While those are well within the realm of possibility, other things like attaching structure type properties are probably not possible with this approach, so it is unlikely that the existing system could be subsumed by one like this one.&lt;/p&gt;

&lt;p&gt;Additionally, this implementation would almost certainly need numerous improvements before being useful to most programmers:&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Good error reporting for failure cases.&lt;/strong&gt; Right now, even something obvious like calling a method on values that do not implement it simply fails with an error produced by &lt;code&gt;hash-ref&lt;/code&gt;. In a more interesting sense, using the arity to generate compile-time error messages for &lt;code&gt;define-instance&lt;/code&gt; would be a nice improvement.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Support for Racket primitive data types.&lt;/strong&gt; This might require some cooperation from Racket itself to permit an elegant implementation, but they could also just be special-cased. So long as lookup for primitives was done &lt;em&gt;after&lt;/em&gt; consulting the main dispatch table, there wouldn’t be any performance hit for non-primitive types.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Option to supply fallback implementations.&lt;/strong&gt; This wouldn’t be too hard at all, though it’s questionable whether or not it would be useful without method groupings like &lt;code&gt;define/generic&lt;/code&gt; provides. There would likely also need to be some sort of way to check if a set of values implements a particular method.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Better cooperation with structure inspectors to alleviate the need for all structures to be transparent.&lt;/strong&gt; It’s currently unclear to me how exactly this works and how it &lt;em&gt;should&lt;/em&gt; work. There might be a better way to do this without mucking with inspectors.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Much more flexible argument lists, including the ability to specify arguments that are not used for dispatch.&lt;/strong&gt; This is really a pretty fundamental requirement, but the parsing required was significant enough for me to put it off for this initial prototype.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Scribble forms to document generic methods and their instances.&lt;/strong&gt; This is something &lt;code&gt;racket/generic&lt;/code&gt; &lt;em&gt;doesn’t&lt;/em&gt; have, and it has suffered for it. It would be very nice to have easy documentation forms for multimethods.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;&lt;strong&gt;Proper consideration of struct subtyping.&lt;/strong&gt; Racket structs support subtyping, which I have not given much thought for this prototype. It is possible that subtyping violates constraints I had assumed would hold, so reviewing the existing code with that context would be useful.&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;I’m not sure how much effort is involved in most of the above ideas, and in fact I’m not even completely sure how useful this system is to begin with. I have not found myself reaching much for multiple dispatch in my time as a Racket programmer, but that could simply be because it was previously unavailable. It will be interesting to see if that changes now that I have built this system, even if it is a bit rough around the edges.&lt;/p&gt;

&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Despite the lack of need for multiple dispatch to solve most problems, as indicated by its general lack of support in mainstream programming languages, it’s a nice tool to have in the toolbox, and it &lt;em&gt;is&lt;/em&gt; asked for in the Racket community from time to time (perhaps due to its familiarity in other parts of the Lisp world). Time will tell if pointing people to something like this will create or stifle interest in multiple dispatch for Racket.&lt;/p&gt;

&lt;p&gt;The source for the &lt;a href="https://github.com/lexi-lambda/racket-multimethod"&gt;&lt;code&gt;multimethod&lt;/code&gt; package can be found here&lt;/a&gt; if you are at all interested in playing with it yourself.&lt;/p&gt;</description></item>
  <item>
   <title>ADTs in Typed Racket with macros</title>
   <link>http://lexi-lambda.github.io/blog/2015/12/21/adts-in-typed-racket-with-macros/?utm_source=racket&amp;utm_medium=RSS</link>
   <guid>urn:http-lexi-lambda-github-io:-blog-2015-12-21-adts-in-typed-racket-with-macros</guid>
   <pubDate>Mon, 21 Dec 2015 17:57:07 UT</pubDate>
   <description>
&lt;p&gt;Macros are one of Racket&amp;rsquo;s flagship features, and its macro system really is state of the art. Of course, it can sometimes be difficult to demonstrate &lt;em&gt;why&lt;/em&gt; macros are so highly esteemed, in part because it can be hard to find self-contained examples of using macros in practice. Of course, one thing that macros are perfect for is filling a &amp;ldquo;hole&amp;rdquo; in the language by introducing a feature a language lacks, and one of those features in Typed Racket is &lt;strong&gt;ADTs&lt;/strong&gt;.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="warning-this-is-not-a-macro-tutorial"&gt;Warning: this is not a macro tutorial&lt;/h1&gt;

&lt;p&gt;First, a disclaimer: this post assumes at least some knowledge of Scheme/Racket macros. Ideally, you would be familiar with Racket itself. But if you aren&amp;rsquo;t, fear not: if you get lost, don&amp;rsquo;t worry. Hold on to the bigger picture, and you&amp;rsquo;ll likely learn more than someone who knows enough to follow all the way through. If you &lt;em&gt;are&lt;/em&gt; interested in learning about macros, I must recommend Greg Hendershott&amp;rsquo;s &lt;a href="http://www.greghendershott.com/fear-of-macros/"&gt;Fear of Macros&lt;/a&gt;. It is good. This is not that.&lt;/p&gt;

&lt;p&gt;Now, with that out of the way, let&amp;rsquo;s get started.&lt;/p&gt;

&lt;h1 id="what-were-building"&gt;What we&amp;rsquo;re building&lt;/h1&gt;

&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Algebraic_data_type"&gt;Algebraic data types&lt;/a&gt;, or &lt;em&gt;ADTs&lt;/em&gt;, are a staple of the ML family of functional programming languages. I won&amp;rsquo;t go into detail here—I want to focus on the implementation—but they&amp;rsquo;re a very descriptive way of modeling data that encourages designing functions in terms of pattern-matching, something that Racket is already good at.&lt;/p&gt;

&lt;p&gt;Racket also already has a facility for creating custom data structures in the form of &lt;em&gt;structs&lt;/em&gt;, which are extremely flexible, but also a little verbose. Racket structs are more powerful than we need, but that means we can implement our ADTs in terms of Racket&amp;rsquo;s struct system.&lt;/p&gt;

&lt;p&gt;With that in mind, what should our syntax look like? Well, let&amp;rsquo;s consider a quintessential example of ADTs: modeling a simple tree. For now, let&amp;rsquo;s just consider a tree of integers. For reference, the Haskell syntax for such a data structure would look like this:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Empty&lt;/span&gt;
          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
          &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Node&lt;/span&gt; &lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="kt"&gt;Tree&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This already demonstrates a few of the core things we&amp;rsquo;ll need to build:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;Each ADT has a &lt;em&gt;data type&lt;/em&gt;, in this case &lt;code&gt;Tree&lt;/code&gt;. This name only exists in the world of types, it isn&amp;rsquo;t a value.&lt;/li&gt;
 &lt;li&gt;Each ADT has various &lt;em&gt;data constructors&lt;/em&gt;, in this case &lt;code&gt;Leaf&lt;/code&gt; and &lt;code&gt;Node&lt;/code&gt;.&lt;/li&gt;
 &lt;li&gt;Each data constructor may accept any number of arguments, each of which have a specific type.&lt;/li&gt;
 &lt;li&gt;The types that data constructors may accept include the ADT&amp;rsquo;s datatype itself—that is, definitions can be recursive.&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Of course, there&amp;rsquo;s one more important feature we&amp;rsquo;re missing: polymorphism. Our definition of a tree is overly-specific, and really, it should be able to hold any kind of data, not just integers. In Haskell, we can do that by adding a type parameter:&lt;/p&gt;

&lt;div class="brush: haskell"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;data&lt;/span&gt; &lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="ow"&gt;=&lt;/span&gt; &lt;span class="kt"&gt;Empty&lt;/span&gt;
            &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
            &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kt"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;With this in mind, we can add a fifth and final point to our list:&lt;/p&gt;

&lt;p&gt; 
 &lt;ol start="5"&gt;
  &lt;li&gt;ADTs must be able to be parametrically polymorphic.&lt;/li&gt;&lt;/ol&gt;&lt;/p&gt;

&lt;p&gt;That covers all of our requirements for basic ADTs. Now we&amp;rsquo;re ready to port this idea to Racket.&lt;/p&gt;

&lt;h2 id="describing-adts-in-racket"&gt;Describing ADTs in Racket&lt;/h2&gt;

&lt;p&gt;How should we take the Haskell syntax for an ADT definition and adapt it to Racket&amp;rsquo;s parenthetical s-expressions? By taking some cues from the Haskell implementation, Typed Racket&amp;rsquo;s type syntax, and Racket&amp;rsquo;s naming conventions, a fairly logical syntax emerges:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-datatype&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;Empty&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This looks pretty good. Just like with the Haskell implementation, &lt;code&gt;Tree&lt;/code&gt; should only exist at the type level, and &lt;code&gt;Empty&lt;/code&gt;, &lt;code&gt;Leaf&lt;/code&gt;, and &lt;code&gt;Node&lt;/code&gt; should be constructor functions. Our syntax mirrors Racket function application, too—the proper way to create a leaf would be &lt;code&gt;(Leaf 7)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now that we can create ADT values, how should we extract the values from them? Well, just like in ML-likes, we can use pattern-matching. We don&amp;rsquo;t need to reinvent the wheel for this one; we should be able to just use Racket&amp;rsquo;s &lt;code&gt;&lt;a href="http://docs.racket-lang.org/reference/match.html#(form._((lib._racket/match..rkt)._match))" style="color: inherit"&gt;match&lt;/a&gt;&lt;/code&gt; with our datatypes. For example, a function that sums all the values in a tree might look like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;tree-sum&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Integer))" style="color: inherit"&gt;Integer&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/function-contracts.html#(form._((lib._racket/contract/base..rkt)._-~3e))" style="color: inherit"&gt;-&amp;gt;&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Integer))" style="color: inherit"&gt;Integer&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree-sum&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/match.html#(form._((lib._racket/match..rkt)._match))" style="color: inherit"&gt;match&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;tree&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;               &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="n"&gt;n&lt;/span&gt;               &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree-sum&lt;/span&gt; &lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tree-sum&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Given that Racket&amp;rsquo;s &lt;code&gt;struct&lt;/code&gt; form automatically produces identifiers that cooperate with &lt;code&gt;match&lt;/code&gt;, this shouldn&amp;rsquo;t be hard at all. And with our syntax settled, we&amp;rsquo;re ready to begin implementation.&lt;/p&gt;

&lt;h1 id="implementing-adts-as-syntax"&gt;Implementing ADTs as syntax&lt;/h1&gt;

&lt;p&gt;Now for the fun part. To implement our ADT syntax, we&amp;rsquo;ll employ Racket&amp;rsquo;s industrial-strength macro DSL, &lt;a href="http://docs.racket-lang.org/syntax/stxparse.html"&gt;&lt;code&gt;syntax/parse&lt;/code&gt;&lt;/a&gt;. The &lt;code&gt;syntax/parse&lt;/code&gt; library works like the traditional Scheme &lt;code&gt;syntax-case&lt;/code&gt; on steroids, and one of the most useful features is the ability to define &amp;ldquo;syntax classes&amp;rdquo; that encapsulate reusable parsing rules into declarative components.&lt;/p&gt;

&lt;p&gt;Since this is not a macro tutorial, the following implementation assumes you already know how to use &lt;code&gt;syntax/parse&lt;/code&gt;. However, all of the concepts here are well within the reaches of any intermediate macrologist, so don&amp;rsquo;t be intimidated by some of the more complex topics at play.&lt;/p&gt;

&lt;h2 id="parsing-types-with-a-syntax-class"&gt;Parsing types with a syntax class&lt;/h2&gt;

&lt;p&gt;To implement ADTs, we&amp;rsquo;re going to want to define exactly one syntax class, a class that describes the grammar for a type. As we&amp;rsquo;ve seen, types can be bare identifiers, like &lt;code&gt;Tree&lt;/code&gt;, or they can be identifiers with parameters, like &lt;code&gt;(Tree a)&lt;/code&gt;. We&amp;rsquo;ll want to cover both cases.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin-for-syntax))" style="color: inherit"&gt;begin-for-syntax&lt;/a&gt;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html#(form._((lib._syntax/parse..rkt)._define-syntax-class))" style="color: inherit"&gt;define-syntax-class&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html#(form._((lib._syntax/parse..rkt)._pattern))" style="color: inherit"&gt;pattern&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;name:id&lt;/span&gt; &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html#(form._((lib._syntax/parse..rkt)._pattern))" style="color: inherit"&gt;pattern&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name:id&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html#(form._((lib._syntax/parse..rkt)._......+))" style="color: inherit"&gt;...+&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This syntax class has two rules, one that&amp;rsquo;s a bare identifier, and one that&amp;rsquo;s a list. The ellipsis followed by a plus (&lt;code&gt;...+&lt;/code&gt;) in the second example means &amp;ldquo;one or more&amp;rdquo;, so parsing those parameters will automatically be handled for us. In the bare identifier example, we use &lt;code&gt;#:attr&lt;/code&gt; to give the &lt;code&gt;param&lt;/code&gt; attribute the default value of an empty list, so this syntax class will actually &lt;em&gt;normalize&lt;/em&gt; the input we get in addition to actually parsing it.&lt;/p&gt;

&lt;h2 id="a-first-attempt-at-define-datatype"&gt;A first attempt at &lt;code&gt;define-datatype&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;Now we can move on to actually implementing &lt;code&gt;define-datatype&lt;/code&gt;. The rules are simple: we need to generate a structure type for each one of the data constructors, and we need to generate a type definition for the parent type itself. This is pretty simple to implement using &lt;code&gt;syntax-parser&lt;/code&gt;, which actually does the parsing for our macro.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit"&gt;define-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;define-datatype&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#(form._((lib._syntax/parse..rkt)._syntax-parser))" style="color: inherit"&gt;syntax-parser&lt;/a&gt;&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt).__))" style="color: inherit"&gt;_&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;type-name:type&lt;/span&gt; &lt;span class="n"&gt;data-constructor:type&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="p"&gt;]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This definition will do all the parsing we need. It parses the entire macro &amp;ldquo;invocation&amp;rdquo;, ignoring the first datum with &lt;code&gt;_&lt;/code&gt; (which will just be the identifier &lt;code&gt;define-datatype&lt;/code&gt;), then expecting a &lt;code&gt;type-name&lt;/code&gt;, which uses the &lt;code&gt;type&lt;/code&gt; syntax class we defined above. Next, we expect zero or more &lt;code&gt;data-constructor&lt;/code&gt;s, which also use the &lt;code&gt;type&lt;/code&gt; syntax class. That&amp;rsquo;s all we have to do for parsing. We now have all the information we need to actually output the expansion for the macro.&lt;/p&gt;

&lt;p&gt;Of course, it won&amp;rsquo;t be that easy: this is the difficult part. The first step is to generate a Racket struct for each data constructor. We can do this pretty easily with some simple use of Racket&amp;rsquo;s syntax templating facility. A naïve attempt would look like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit"&gt;define-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;define-datatype&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#(form._((lib._syntax/parse..rkt)._syntax-parser))" style="color: inherit"&gt;syntax-parser&lt;/a&gt;&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt).__))" style="color: inherit"&gt;_&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;type-name:type&lt;/span&gt; &lt;span class="n"&gt;data-constructor:type&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
     &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))" style="color: inherit"&gt;begin&lt;/a&gt;&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" style="color: inherit"&gt;struct&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
         &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;This is actually really close to being correct. This will generate a struct definition for each &lt;code&gt;data-constructor&lt;/code&gt;, where each struct has the name of the data constructor and the same number of fields as arguments provided. The trouble is that in Racket structs, all of the fields have &lt;em&gt;names&lt;/em&gt;, but in our ADTs, all the fields are anonymous and by-position. Currently, we&amp;rsquo;re just using the same name for &lt;em&gt;all&lt;/em&gt; the fields, &lt;code&gt;f&lt;/code&gt;, so if any data constructor has two or more fields, we&amp;rsquo;ll get an error.&lt;/p&gt;

&lt;p&gt;Since we don&amp;rsquo;t care about the field names, what we want to do is just generate random names for every field. To do this, we can use a Racket function called &lt;code&gt;generate-temporary&lt;/code&gt;, which generates random identifiers. Our next attempt might look like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))" style="color: inherit"&gt;begin&lt;/a&gt;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" style="color: inherit"&gt;struct&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt;
      &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/reference/syntax-util.html#(def._((lib._racket/syntax..rkt)._generate-temporary))" style="color: inherit"&gt;generate-temporary&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;#,&lt;/code&gt; lets us &amp;ldquo;escape&amp;rdquo; from the template to execute &lt;code&gt;(generate-temporary)&lt;/code&gt; and interpolate its result into the syntax. Unfortunately, this doesn&amp;rsquo;t work. We &lt;em&gt;do&lt;/em&gt; generate a random field name, but the ellipsis will re-use the same generated value when it repeats the fields, rendering our whole effort pointless. We need to generate the field names once per type.&lt;/p&gt;

&lt;h2 id="more-leveraging-syntax-classes"&gt;More leveraging syntax classes&lt;/h2&gt;

&lt;p&gt;As it turns out, this is &lt;em&gt;also&lt;/em&gt; easy to do with syntax classes. We can add an extra attribute to our &lt;code&gt;type&lt;/code&gt; syntax class to generate a random identifier with each one. Again, we can use &lt;code&gt;#:attr&lt;/code&gt; to do that automatically. Our new definition for &lt;code&gt;type&lt;/code&gt; will look like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin-for-syntax))" style="color: inherit"&gt;begin-for-syntax&lt;/a&gt;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html#(form._((lib._syntax/parse..rkt)._define-syntax-class))" style="color: inherit"&gt;define-syntax-class&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html#(form._((lib._syntax/parse..rkt)._pattern))" style="color: inherit"&gt;pattern&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;name:id&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field-id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html#(form._((lib._syntax/parse..rkt)._pattern))" style="color: inherit"&gt;pattern&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name:id&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html#(form._((lib._syntax/parse..rkt)._......+))" style="color: inherit"&gt;...+&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field-id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/stxops.html#(def._((lib._racket/private/stxcase-scheme..rkt)._generate-temporaries))" style="color: inherit"&gt;generate-temporaries&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Here we&amp;rsquo;re using &lt;code&gt;generate-temporaries&lt;/code&gt; instead of &lt;code&gt;generate-temporary&lt;/code&gt;, which will conveniently generate a new identifier for each of the elements in the list we provide it. This way, we&amp;rsquo;ll get a fresh identifier for each &lt;code&gt;param&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can now fix our macro to use this &lt;code&gt;field-id&lt;/code&gt; attribute instead of the static field name:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))" style="color: inherit"&gt;begin&lt;/a&gt;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" style="color: inherit"&gt;struct&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt;
      &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;data-constructor.field-id&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;h2 id="creating-the-supertype"&gt;Creating the supertype&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;re almost done—now we just need to implement our overall type, the one defined by &lt;code&gt;type-name&lt;/code&gt;. This is implemented as a trivial type alias, but we need to ensure that polymorphic types are properly handled. For example, a non-polymorphic type would need to be handled like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed/racket/base..rkt)._define-type))" style="color: inherit"&gt;define-type&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._.U))" style="color: inherit"&gt;U&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;Empty&lt;/span&gt; &lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;Node&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;However, a polymorphic type alias would need to include the type parameters in each subtype, like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed/racket/base..rkt)._define-type))" style="color: inherit"&gt;define-type&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._.U))" style="color: inherit"&gt;U&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;How can we do this? Well, so far, we&amp;rsquo;ve been very declarative by using syntax patterns, templates, and classes. However, this is a more pernicious problem to solve with our declarative tools. Fortunately, it&amp;rsquo;s very easy to fall back to using &lt;strong&gt;procedural macros&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;To build each properly-instantiated type, we&amp;rsquo;ll use a combination of &lt;code&gt;define/with-syntax&lt;/code&gt; and Racket&amp;rsquo;s list comprehensions, &lt;code&gt;for/list&lt;/code&gt;. The &lt;code&gt;define/with-syntax&lt;/code&gt; form binds values to pattern identifiers, which can be used within syntax patterns just like the ones bound by &lt;code&gt;syntax-parser&lt;/code&gt;. This will allow us to break up our result into multiple steps. Technically, &lt;code&gt;define/with-syntax&lt;/code&gt; is not strictly necessary—we could just use &lt;code&gt;#`&lt;/code&gt; and &lt;code&gt;#,&lt;/code&gt;—but it&amp;rsquo;s cleaner to work with.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll start by defining a set of instantiated data constructor types, one per &lt;code&gt;data-constructor&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/reference/syntax-util.html#(form._((lib._racket/syntax..rkt)._define/with-syntax))" style="color: inherit"&gt;define/with-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/for.html#(form._((lib._racket/private/base..rkt)._for/list))" style="color: inherit"&gt;for/list&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/unstable/sequence.html#(def._((lib._unstable/sequence..rkt)._in-syntax))" style="color: inherit"&gt;in-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
    &lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now we can fill in the body with any code we&amp;rsquo;d like, so long as each body returns a syntax object. We can use some trivial branching logic to determine which form we need:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/reference/syntax-util.html#(form._((lib._racket/syntax..rkt)._define/with-syntax))" style="color: inherit"&gt;define/with-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/for.html#(form._((lib._racket/private/base..rkt)._for/list))" style="color: inherit"&gt;for/list&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/unstable/sequence.html#(def._((lib._unstable/sequence..rkt)._in-syntax))" style="color: inherit"&gt;in-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" style="color: inherit"&gt;if&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/syntax-helpers.html#(def._((lib._syntax/stx..rkt)._stx-null~3f))" style="color: inherit"&gt;stx-null?&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;name&lt;/span&gt;
        &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now with our definition for &lt;code&gt;data-type&lt;/code&gt;, we can implement our type alias for the supertype extremely easily:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed/racket/base..rkt)._define-type))" style="color: inherit"&gt;define-type&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;type-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._.U))" style="color: inherit"&gt;U&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;h2 id="putting-it-all-together"&gt;Putting it all together&lt;/h2&gt;

&lt;p&gt;There&amp;rsquo;s just one more thing to do before we can call this macro finished: we need to ensure that all the type parameters defined by &lt;code&gt;type-name&lt;/code&gt; are in scope for each data constructor&amp;rsquo;s structure definition. We can do this by making use of &lt;code&gt;type-name.param&lt;/code&gt; within each produced struct definition, resulting in this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))" style="color: inherit"&gt;begin&lt;/a&gt;&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" style="color: inherit"&gt;struct&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;data-constructor.field-id&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;And we&amp;rsquo;re done! The final macro, now completed, looks like this:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin-for-syntax))" style="color: inherit"&gt;begin-for-syntax&lt;/a&gt;&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html#(form._((lib._syntax/parse..rkt)._define-syntax-class))" style="color: inherit"&gt;define-syntax-class&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html#(form._((lib._syntax/parse..rkt)._pattern))" style="color: inherit"&gt;pattern&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;name:id&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field-id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-specifying.html#(form._((lib._syntax/parse..rkt)._pattern))" style="color: inherit"&gt;pattern&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name:id&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/stxparse-patterns.html#(form._((lib._syntax/parse..rkt)._......+))" style="color: inherit"&gt;...+&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
             &lt;span class="kd"&gt;#:attr&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field-id&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/stxops.html#(def._((lib._racket/private/stxcase-scheme..rkt)._generate-temporaries))" style="color: inherit"&gt;generate-temporaries&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit"&gt;define-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;define-datatype&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/Parsing_Syntax.html#(form._((lib._syntax/parse..rkt)._syntax-parser))" style="color: inherit"&gt;syntax-parser&lt;/a&gt;&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt).__))" style="color: inherit"&gt;_&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;type-name:type&lt;/span&gt; &lt;span class="n"&gt;data-constructor:type&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

     &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/reference/syntax-util.html#(form._((lib._racket/syntax..rkt)._define/with-syntax))" style="color: inherit"&gt;define/with-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
       &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/for.html#(form._((lib._racket/private/base..rkt)._for/list))" style="color: inherit"&gt;for/list&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/unstable/sequence.html#(def._((lib._unstable/sequence..rkt)._in-syntax))" style="color: inherit"&gt;in-syntax&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data-constructor.name&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))])&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" style="color: inherit"&gt;if&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/syntax/syntax-helpers.html#(def._((lib._syntax/stx..rkt)._stx-null~3f))" style="color: inherit"&gt;stx-null?&lt;/a&gt;&lt;/span&gt; &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
             &lt;span class="n"&gt;name&lt;/span&gt;
             &lt;span class="o"&gt;#`&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;#,&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;

     &lt;span class="o"&gt;#'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))" style="color: inherit"&gt;begin&lt;/a&gt;&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define-struct.html#(form._((lib._racket/private/base..rkt)._struct))" style="color: inherit"&gt;struct&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type-name.param&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;data-constructor.name&lt;/span&gt;
           &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;data-constructor.field-id&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;data-constructor.param&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;
         &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed/racket/base..rkt)._define-type))" style="color: inherit"&gt;define-type&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;type-name&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._.U))" style="color: inherit"&gt;U&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;data-type&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit"&gt;...&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)))]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;It&amp;rsquo;s a little bit dense, certainly, but it is not as complicated or scary as it might seem. It&amp;rsquo;s a simple, mostly declarative, powerful way to transform a DSL into ordinary Typed Racket syntax, and now all we have to do is put it to use.&lt;/p&gt;

&lt;h1 id="using-our-adts"&gt;Using our ADTs&lt;/h1&gt;

&lt;p&gt;With the macro built, we can now actually use our ADTs using the syntax we described! The following is now &lt;em&gt;valid code&lt;/em&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-datatype&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;Empty&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Tree&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;

&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3e))" style="color: inherit"&gt;&amp;gt;&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._-))" style="color: inherit"&gt;-&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Positive-.Byte))" style="color: inherit"&gt;Positive-Byte&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Node&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Empty&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Leaf&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We can use this to define common data types, such as Haskell&amp;rsquo;s &lt;code&gt;Maybe&lt;/code&gt;:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-datatype&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Nothing))" style="color: inherit"&gt;Nothing&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;maybe-default&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._.All))" style="color: inherit"&gt;All&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/function-contracts.html#(form._((lib._racket/contract/base..rkt)._-~3e))" style="color: inherit"&gt;-&amp;gt;&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;maybe-default&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/match.html#(form._((lib._racket/match..rkt)._match))" style="color: inherit"&gt;match&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Nothing))" style="color: inherit"&gt;Nothing&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;]))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;maybe-then&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types-extra..rkt)._.All))" style="color: inherit"&gt;All&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/function-contracts.html#(form._((lib._racket/contract/base..rkt)._-~3e))" style="color: inherit"&gt;-&amp;gt;&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/function-contracts.html#(form._((lib._racket/contract/base..rkt)._-~3e))" style="color: inherit"&gt;-&amp;gt;&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Maybe&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;maybe-then&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/match.html#(form._((lib._racket/match..rkt)._match))" style="color: inherit"&gt;match&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Just&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Nothing))" style="color: inherit"&gt;Nothing&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Nothing))" style="color: inherit"&gt;Nothing&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)]))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;And of course, we can also use it to define ADTs that use concrete types rather that type parameters, if we so desire. This implements a small mathematical language, along with a trivial interpreter:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define-datatype&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Number))" style="color: inherit"&gt;Number&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Add&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Subtract&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Multiply&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Divide&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="n"&gt;Expr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Expr&lt;/span&gt; &lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/function-contracts.html#(form._((lib._racket/contract/base..rkt)._-~3e))" style="color: inherit"&gt;-&amp;gt;&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Number))" style="color: inherit"&gt;Number&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/match.html#(form._((lib._racket/match..rkt)._match))" style="color: inherit"&gt;match&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="n"&gt;x&lt;/span&gt;                            &lt;span class="p"&gt;]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Add&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;      &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit"&gt;+&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Subtract&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._-))" style="color: inherit"&gt;-&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Multiply&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))" style="color: inherit"&gt;*&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))]&lt;/span&gt;
    &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;Divide&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._/))" style="color: inherit"&gt;/&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;))]))&lt;/span&gt;

&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3e))" style="color: inherit"&gt;&amp;gt;&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;evaluate&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Add&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Multiply&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Divide&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Value&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;))))&lt;/span&gt;
&lt;span class="mi"&gt;4&lt;/span&gt; &lt;span class="m"&gt;1/2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;There&amp;rsquo;s all the power of ADTs, right in Racket, all implemented in 22 lines of code. If you&amp;rsquo;d like to see all the code together in a runnable form, &lt;a href="https://gist.github.com/lexi-lambda/18cf7a9156f743a1317e"&gt;I&amp;rsquo;ve put together a gist here&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id="conclusions-and-credit"&gt;Conclusions and credit&lt;/h1&gt;

&lt;p&gt;This isn&amp;rsquo;t the simplest macro to create, nor is it the most complex. The code examples might not even make much sense until you try it out yourself. Macros, like any difficult concept, are not always easy to pick up, but they certainly &lt;em&gt;are&lt;/em&gt; powerful. The ability to extend the language in such a way, in the matter of minutes, is unparalleled in languages other than Lisp.&lt;/p&gt;

&lt;p&gt;This is, of course, a blessing and a curse. Lisps reject some of the syntactic landmarks that often aid in readability for the power to abstract programs into their bare components. In the end, is this uniform conciseness more or less readable? That&amp;rsquo;s an incredibly subjective question, one that has prompted powerfully impassioned discussions, and I will not attempt to argue one way or the other here.&lt;/p&gt;

&lt;p&gt;That said, I think it&amp;rsquo;s pretty cool.&lt;/p&gt;

&lt;p&gt;Finally, I must give credit where credit is due. Thanks to &lt;a href="http://andmkent.com"&gt;Andrew M. Kent&lt;/a&gt; for the creation of the &lt;a href="https://github.com/andmkent/datatype"&gt;datatype&lt;/a&gt; package, which served as the inspiration for this blog post. Many thanks to &lt;a href="http://www.ccs.neu.edu/home/samth/"&gt;Sam Tobin-Hochstadt&lt;/a&gt; for his work creating Typed Racket, as well as helping me dramatically simplify the implementation used in this blog post. Also thanks to &lt;a href="http://www.ccs.neu.edu/home/ryanc/"&gt;Ryan Culpepper&lt;/a&gt; and &lt;a href="http://www.ccs.neu.edu/home/matthias/"&gt;Matthias Felleisen&lt;/a&gt; for their work on creating &lt;code&gt;syntax/parse&lt;/code&gt;, which is truly a marvelous tool for exploring the world of macros, and, of course, a big thanks to &lt;a href="http://www.cs.utah.edu/~mflatt/"&gt;Matthew Flatt&lt;/a&gt; for his implementation of hygiene in Racket, as well as much of the rest of Racket itself. Not to mention the entire legacy of those who formulated the foundations of the Scheme macro system and created the framework for all of this to be possible so many decades later.&lt;/p&gt;

&lt;p&gt;Truly, working in Racket feels like standing on the shoulders of giants. If you&amp;rsquo;re intrigued, give it a shot. It&amp;rsquo;s a fun feeling.&lt;/p&gt;</description></item>
  <item>
   <title>Managing application configuration with Envy</title>
   <link>http://lexi-lambda.github.io/blog/2015/08/30/managing-application-configuration-with-envy/?utm_source=racket&amp;utm_medium=RSS</link>
   <guid>urn:http-lexi-lambda-github-io:-blog-2015-08-30-managing-application-configuration-with-envy</guid>
   <pubDate>Sun, 30 Aug 2015 16:05:37 UT</pubDate>
   <description>
&lt;p&gt;Application configuration can be a pain. Modern web apps don&amp;rsquo;t live on dedicated boxes, they run on VPSes somewhere in the amorphous &amp;ldquo;cloud&amp;rdquo;, and keeping configuration out of your application&amp;rsquo;s repository can seem like more trouble than it&amp;rsquo;s worth. Fortunately, &lt;a href="http://12factor.net"&gt;The Twelve-Factor App&lt;/a&gt; provides a set of standards for keeping web apps sane, and &lt;a href="http://12factor.net/config"&gt;one of those guidelines advises keeping configuration in the environment&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href="https://github.com/lexi-lambda/envy"&gt;Envy&lt;/a&gt; is the declarative bridge between Racket code and the outside world of the environment.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="introducing-envy"&gt;Introducing Envy&lt;/h1&gt;

&lt;p&gt;I built Envy to distill the common tasks needed when working with environment variables into a single, declarative interface that eliminates boilerplate and makes it easy to see which environment variables an application depends on (instead of having them littered throughout the codebase). Using it is simple. Just require &lt;code&gt;envy&lt;/code&gt; and you&amp;rsquo;re good to go.&lt;/p&gt;

&lt;p&gt;The best way to use Envy is to create a &amp;ldquo;manifest&amp;rdquo; module that declares all the environment variables your application might use. For example, the following module is a manifest that describes an application that uses three environment variables:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;; environment.rkt&lt;/span&gt;
&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;typed/racket/base&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._require))" style="color: inherit"&gt;require&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;envy&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;define/provide-environment&lt;/span&gt;
  &lt;span class="n"&gt;api-token&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;log-level&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Symbol))" style="color: inherit"&gt;Symbol&lt;/a&gt;&lt;/span&gt; &lt;span class="kd"&gt;#:default&lt;/span&gt; &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="ss"&gt;info&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;parallel?&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/special-forms.html#(form._((lib._typed-racket/base-env/prims..rkt)._~3a))" style="color: inherit"&gt;:&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;&lt;a href="http://docs.racket-lang.org/ts-reference/type-ref.html#(form._((lib._typed-racket/base-env/base-types..rkt)._.Boolean))" style="color: inherit"&gt;Boolean&lt;/a&gt;&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;When this module is required, Envy will automatically do the following:&lt;/p&gt;

&lt;ol&gt;
 &lt;li&gt;
  &lt;p&gt;Envy will check the values of three environment variables: &lt;code&gt;API_TOKEN&lt;/code&gt;, &lt;code&gt;LOG_LEVEL&lt;/code&gt;, and &lt;code&gt;PARALLEL&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;If either &lt;code&gt;API_TOKEN&lt;/code&gt; or &lt;code&gt;PARALLEL&lt;/code&gt; is not set, an error will be raised:&lt;/p&gt;
  &lt;pre&gt;&lt;code&gt;envy: The required environment variable "API_TOKEN" is not defined.&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The values for &lt;code&gt;LOG_LEVEL&lt;/code&gt; and &lt;code&gt;PARALLEL&lt;/code&gt; will be parsed to match their type annotations.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;If &lt;code&gt;LOG_LEVEL&lt;/code&gt; is not set, it will use the default value, &lt;code&gt;'info&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
 &lt;li&gt;
  &lt;p&gt;The values will be stored in &lt;code&gt;api-token&lt;/code&gt;, &lt;code&gt;log-level&lt;/code&gt;, and &lt;code&gt;parallel?&lt;/code&gt;, all of which will be provided by the enclosing module.&lt;/p&gt;&lt;/li&gt;&lt;/ol&gt;

&lt;p&gt;Now just &lt;code&gt;(require (prefix-in env: "environment.rkt"))&lt;/code&gt;, and the environment variables are guaranteed to be available in your application&amp;rsquo;s code.&lt;/p&gt;

&lt;h1 id="working-with-typed-racket"&gt;Working with Typed Racket&lt;/h1&gt;

&lt;p&gt;As you may have noticed by the example above, Envy is built with Typed Racket in mind. In fact, &lt;code&gt;define/provide-environment&lt;/code&gt; will &lt;em&gt;only&lt;/em&gt; work within a Typed Racket module, but that doesn&amp;rsquo;t mean Envy can&amp;rsquo;t be used with plain Racket—the manifest module can always be required by any kind of Racket module.&lt;/p&gt;

&lt;p&gt;However, when using Typed Racket, Envy provides additional bonuses. Environment variables are inherently untyped—they&amp;rsquo;re all just strings—but Envy assigns the proper type to each environment variable automatically, so no casting is necessary.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; parallel?
- : Boolean
#t&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Envy really shines when using optional environment variables with the &lt;code&gt;#:default&lt;/code&gt; option. The type of the value given to &lt;code&gt;#:default&lt;/code&gt; doesn&amp;rsquo;t need to be the same type of the environment variable itself, and if it isn&amp;rsquo;t, Envy will assign the value a union type.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; (define-environment
    [num-threads : Positive-Integer #:default #f])
&amp;gt; num-threads
- : (U Positive-Integer #f)
#f&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This added level of type-safety means it&amp;rsquo;s easy to manage optional variables that don&amp;rsquo;t have reasonable defaults: the type system will enforce that all code considers the possibility that such variables do not exist.&lt;/p&gt;

&lt;h1 id="and-more"&gt;And more&amp;hellip;&lt;/h1&gt;

&lt;p&gt;To see the full set of features that Envy already provides, &lt;a href="https://lexi-lambda.github.io/envy/envy.html"&gt;take a look at the documentation&lt;/a&gt;. That said, this is just the first release based on my initial use-cases, but I&amp;rsquo;m sure there are more features Envy could have to accommodate common application configuration patterns. If you have an idea that could make Envy better, &lt;a href="https://github.com/lexi-lambda/envy/issues"&gt;open an issue and make a suggestion&lt;/a&gt;! I already have plans for a &lt;code&gt;#lang envy&lt;/code&gt; DSL, which will hopefully cut the boilerplate out in its entirety.&lt;/p&gt;

&lt;p&gt;And finally, to give credit where credit is due, Envy is heavily inspired by &lt;a href="https://github.com/eval/envied"&gt;Envied&lt;/a&gt; (both in name and function), an environment variable manager for Ruby, which I&amp;rsquo;ve used to great effect.&lt;/p&gt;

&lt;p&gt;Try it out!&lt;/p&gt;

&lt;ul&gt;
 &lt;li&gt;&lt;code&gt;raco pkg install envy&lt;/code&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="https://github.com/lexi-lambda/envy"&gt;Envy on GitHub&lt;/a&gt;&lt;/li&gt;
 &lt;li&gt;&lt;a href="https://lexi-lambda.github.io/envy/envy.html"&gt;Envy documentation&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</description></item>
  <item>
   <title>Deploying Racket applications on Heroku</title>
   <link>http://lexi-lambda.github.io/blog/2015/08/22/deploying-racket-applications-on-heroku/?utm_source=racket&amp;utm_medium=RSS</link>
   <guid>urn:http-lexi-lambda-github-io:-blog-2015-08-22-deploying-racket-applications-on-heroku</guid>
   <pubDate>Sat, 22 Aug 2015 14:47:49 UT</pubDate>
   <description>
&lt;p&gt;&lt;a href="https://www.heroku.com"&gt;Heroku&lt;/a&gt; is a &amp;ldquo;platform as a service&amp;rdquo; that provides an incredibly simple way to deploy simple internet applications, and I take liberal advantage of its free tier for testing out simple applications. It has support for a variety of languages built-in, but Racket is not currently among them. Fortunately, Heroku provides an interface for adding custom build processes for arbitrary types of applications, called “buildpacks”. I&amp;rsquo;ve built one for Racket apps, and with just a little bit of configuration, it’s possible to get a Racket webserver running on Heroku.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="building-the-server"&gt;Building the server&lt;/h1&gt;

&lt;p&gt;Racket&amp;rsquo;s &lt;a href="http://docs.racket-lang.org/web-server/index.html"&gt;web-server&lt;/a&gt; package makes building and running a simple server incredibly easy. Here&amp;rsquo;s all the code we&amp;rsquo;ll need to get going:&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;#lang &lt;/span&gt;&lt;span class="nn"&gt;racket&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._require))" style="color: inherit"&gt;require&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;web-server/servlet&lt;/span&gt;
         &lt;span class="n"&gt;web-server/servlet-env&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="n"&gt;req&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;response/xexpr&lt;/span&gt;
   &lt;span class="o"&gt;'&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;html&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;head&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;title&lt;/span&gt; &lt;span class="s2"&gt;"Racket Heroku App"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
          &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;body&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;h1&lt;/span&gt; &lt;span class="s2"&gt;"It works!"&lt;/span&gt;&lt;span class="p"&gt;)))))&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serve/servlet&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt; &lt;span class="kd"&gt;#:servlet-path&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Running the above file will start up the server on the default port, 8080. When running on Heroku, however, we&amp;rsquo;re required to bind to the port that Heroku provides via the &lt;code&gt;PORT&lt;/code&gt; environment variable. We can access this using the Racket &lt;code&gt;&lt;a href="http://docs.racket-lang.org/reference/envvars.html#(def._((lib._racket/private/misc..rkt)._getenv))" style="color: inherit"&gt;getenv&lt;/a&gt;&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Additionally, the Racket web server specifically binds to localhost, but Heroku doesn&amp;rsquo;t allow that restriction, so we need to pass &lt;code&gt;#f&lt;/code&gt; for the &lt;code&gt;#:listen-ip&lt;/code&gt; argument.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit"&gt;define&lt;/a&gt;&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;&lt;a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" style="color: inherit"&gt;if&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/envvars.html#(def._((lib._racket/private/misc..rkt)._getenv))" style="color: inherit"&gt;getenv&lt;/a&gt;&lt;/span&gt; &lt;span class="s2"&gt;"PORT"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                 &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._string-~3enumber))" style="color: inherit"&gt;string-&amp;gt;number&lt;/a&gt;&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;&lt;a href="http://docs.racket-lang.org/reference/envvars.html#(def._((lib._racket/private/misc..rkt)._getenv))" style="color: inherit"&gt;getenv&lt;/a&gt;&lt;/span&gt; &lt;span class="s2"&gt;"PORT"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                 &lt;span class="mi"&gt;8080&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serve/servlet&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
               &lt;span class="kd"&gt;#:servlet-path&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;
               &lt;span class="kd"&gt;#:listen-ip&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
               &lt;span class="kd"&gt;#:port&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Also, by default, &lt;code&gt;serve/servlet&lt;/code&gt; will open a web browser automatically when the program is run, which is very useful for rapid prototyping within something like DrRacket, but we&amp;rsquo;ll want to turn that off.&lt;/p&gt;

&lt;div class="brush: racket"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;serve/servlet&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
               &lt;span class="kd"&gt;#:servlet-path&lt;/span&gt; &lt;span class="s2"&gt;"/"&lt;/span&gt;
               &lt;span class="kd"&gt;#:listen-ip&lt;/span&gt; &lt;span class="no"&gt;#f&lt;/span&gt;
               &lt;span class="kd"&gt;#:port&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;
               &lt;span class="kd"&gt;#:command-line?&lt;/span&gt; &lt;span class="no"&gt;#t&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;That&amp;rsquo;s it! Now we have a Racket web server that can run on Heroku. Obviously it&amp;rsquo;s not a very interesting application right now, but that&amp;rsquo;s fine for our purposes.&lt;/p&gt;

&lt;h1 id="setting-up-our-app-for-heroku"&gt;Setting up our app for Heroku&lt;/h1&gt;

&lt;p&gt;The next step is to actually create an app on Heroku. Don&amp;rsquo;t worry—it&amp;rsquo;s free! That said, explaining precisely how Heroku works is outside the scope of this article. Just make an account, then create an app. I called mine &amp;ldquo;racket-heroku-sample&amp;rdquo;. Once you&amp;rsquo;ve created an app and set up Heroku&amp;rsquo;s command-line tool, you can specify the proper buildpack:&lt;/p&gt;

&lt;div class="brush: sh"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ git init
$ heroku git:remote -a racket-heroku-sample
$ heroku buildpacks:set https://github.com/lexi-lambda/heroku-buildpack-racket
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;We&amp;rsquo;ll also need to pick a particular Racket version before we deploy our app. At the time of this writing, Racket 6.2.1 is the latest version, so I just set the &lt;code&gt;RACKET_VERSION&lt;/code&gt; environment variable as follows:&lt;/p&gt;

&lt;div class="brush: sh"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ heroku config:set &lt;span class="nv"&gt;RACKET_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;6.2.1
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now there&amp;rsquo;s just one thing left to do before we can push to Heroku: we need to tell Heroku what command to use to run our application. To do this, we use something called a &amp;ldquo;Procfile&amp;rdquo; that contains information about the process types for our app. Heroku supports multiple processes of different types, but we&amp;rsquo;re just going to have a single web process.&lt;/p&gt;

&lt;p&gt;Specifically, we just want to run our &lt;code&gt;serve.rkt&lt;/code&gt; module. The Racket buildpack installs the repository as a package, so we can run &lt;code&gt;racket&lt;/code&gt; with the &lt;code&gt;-l&lt;/code&gt; flag to specify a module path, which will be more robust than specifying a filesystem path directly. Therefore, our Procfile will look like this:&lt;/p&gt;

&lt;div class="brush: procfile"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;web: racket -l sample-heroku-app/server
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now all that&amp;rsquo;s left to do is push our repository to Heroku&amp;rsquo;s git remote. Once the build completes, we can &lt;a href="https://racket-heroku-sample.herokuapp.com"&gt;navigate to our app&amp;rsquo;s URL and actually see it running live&lt;/a&gt;!&lt;/p&gt;

&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;That&amp;rsquo;s all that&amp;rsquo;s needed to get a Racket app up and running on Heroku, but it probably isn&amp;rsquo;t the best way to manage a real application. Usually it&amp;rsquo;s best to use a continuous integration service to automatically deploy certain GitHub branches to Heroku, after running the tests, of course. Also, a real application would obviously be a little more complicated.&lt;/p&gt;

&lt;p&gt;That said, this provides the foundation and shell. If you&amp;rsquo;d like to see the sample app used in this post, you can &lt;a href="https://github.com/lexi-lambda/racket-sample-heroku-app"&gt;find it on GitHub here&lt;/a&gt;. For more details on the buildpack itself, &lt;a href="https://github.com/lexi-lambda/heroku-buildpack-racket"&gt;it&amp;rsquo;s also available on GitHub here&lt;/a&gt;.&lt;/p&gt;</description></item>
  <item>
   <title>Automatically deploying a Frog-powered blog to GitHub pages</title>
   <link>http://lexi-lambda.github.io/blog/2015/07/18/automatically-deploying-a-frog-powered-blog-to-github-pages/?utm_source=racket&amp;utm_medium=RSS</link>
   <guid>urn:http-lexi-lambda-github-io:-blog-2015-07-18-automatically-deploying-a-frog-powered-blog-to-github-pages</guid>
   <pubDate>Sat, 18 Jul 2015 19:09:01 UT</pubDate>
   <description>
&lt;p&gt;So, I have a blog now. It&amp;rsquo;s a simple static blog, but what&amp;rsquo;s unique about it is that it&amp;rsquo;s powered by Racket; specifically, it uses &lt;a href="http://www.greghendershott.com"&gt;Greg Hendershott&lt;/a&gt;&amp;rsquo;s fantastic &lt;a href="https://github.com/greghendershott/frog"&gt;Frog&lt;/a&gt; tool. I&amp;rsquo;ve taken this and moulded it to my tastes to build my blog, including configuring automatic deployment via &lt;a href="https://travis-ci.org"&gt;Travis CI&lt;/a&gt;, so my blog is always up-to-date.&lt;/p&gt;
&lt;!-- more--&gt;

&lt;h1 id="setting-up-frog"&gt;Setting up Frog&lt;/h1&gt;

&lt;p&gt;I should note that Frog itself was wonderfully easy to drop in and get running. Just following the readme, a simple &lt;code&gt;raco pkg install frog&lt;/code&gt; followed by &lt;code&gt;raco frog --init&lt;/code&gt; and &lt;code&gt;raco frog -bp&lt;/code&gt; created a running blog and opened it in my web browser. There was nothing more to it. Once that&amp;rsquo;s done, all it takes to write a blog post is &lt;code&gt;raco frog -n "Post Title"&lt;/code&gt;, and you&amp;rsquo;re good to go.&lt;/p&gt;

&lt;p&gt;By default, Frog uses Bootstrap, which provides a lot of the necessary scaffolding for you, but I opted to roll my own layout using flexbox. I also decided to use &lt;a href="http://sass-lang.com"&gt;Sass&lt;/a&gt; for my stylesheets, potentially with support for &lt;a href="http://coffeescript.org"&gt;CoffeeScript&lt;/a&gt; later, so I wanted to have a good flow for compiling all the resources for deployment. To do that, I used &lt;a href="http://gulpjs.com"&gt;Gulp&lt;/a&gt; in conjunction with &lt;a href="https://www.npmjs.com"&gt;NPM&lt;/a&gt; for build and dependency management.&lt;/p&gt;

&lt;p&gt;Going this route has a few advantages, primarily the fact that updating dependencies becomes much easier, and I can build and deploy my blog with just a couple of commands without needing to commit compiled or minified versions of my sources to version control.&lt;/p&gt;

&lt;h1 id="configuring-automatic-deployment-with-travis"&gt;Configuring automatic deployment with Travis&lt;/h1&gt;

&lt;p&gt;Once Frog itself was configured and my styling was finished, I started looking into how to deploy my blog to a GitHub page without needing to check in any of the generated files to source control. I found a couple of resources, the most useful one being &lt;a href="https://gist.github.com/domenic/ec8b0fc8ab45f39403dd"&gt;this Gist&lt;/a&gt;, which describes how to set up deployment for any project. The basic idea is to create a deployment script which will automatically generate your project, initialize a git repository with the generated files, and push to GitHub&amp;rsquo;s special &lt;code&gt;gh-pages&lt;/code&gt; branch.&lt;/p&gt;

&lt;p&gt;To make this easy, Frog can be configured to output to a separate directory via the &lt;code&gt;.frogrc&lt;/code&gt; configuration file. I chose to output to the &lt;code&gt;out&lt;/code&gt; directory:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;output-dir = out&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also configured my Gulp build to output my CSS into the same output directory. Now, all that&amp;rsquo;s necessary in order to deploy the blog to GitHub is to initialize a Git repository in the output directory, and push the files to the remote branch.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cd out
$ git init
$ git add .
$ git commit -m "Deploy to GitHub Pages"
$ git push --force "$REMOTE_URL" master:gh-pages&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The next step is to configure Travis so that it can securely push to the GitHub repository with the required credentials. This can be done with Travis&amp;rsquo;s &lt;a href="http://docs.travis-ci.com/user/encryption-keys/"&gt;encryption keys&lt;/a&gt; along with a GitHub &lt;a href="https://github.com/settings/tokens"&gt;personal access token&lt;/a&gt;. Just install the Travis CLI client, copy the access token, and run a command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install travis
$ travis encrypt GH_TOKEN=&amp;lt;access token...&amp;gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The output of that command is an encrypted value to be placed in an environment variable in the project&amp;rsquo;s &lt;code&gt;.travis.yml&lt;/code&gt; configuration file. The URL for the repository on GitHub will also need to be specified as well:&lt;/p&gt;

&lt;div class="brush: yaml"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;env&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="l l-Scalar l-Scalar-Plain"&gt;global&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;GH_REF&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;github.com/&amp;lt;gh-username&amp;gt;/&amp;lt;gh-repo&amp;gt;.git&amp;#39;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;secure&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;&amp;lt;encrypted data...&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;Now all that&amp;rsquo;s left is configuring the &lt;code&gt;.travis.yml&lt;/code&gt; to run Frog. Since Travis doesn&amp;rsquo;t natively support Racket at the time of this writing, the choice of &amp;ldquo;language&amp;rdquo; is somewhat arbitrary, but since I want Pygments installed for syntax highlighting, I set my project type to &lt;code&gt;python&lt;/code&gt;, then installed Racket and Frog as pre-installation steps.&lt;/p&gt;

&lt;div class="brush: yaml"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;env&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="l l-Scalar l-Scalar-Plain"&gt;global&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;GH_REF&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;github.com/&amp;lt;gh-username&amp;gt;/&amp;lt;gh-repo&amp;gt;.git&amp;#39;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;secure&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;&amp;lt;encrypted data...&amp;gt;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;RACKET_DIR&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;~/racket&amp;#39;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;RACKET_VERSION&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;6.2&amp;#39;&lt;/span&gt;

&lt;span class="l l-Scalar l-Scalar-Plain"&gt;before_install&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone https://github.com/greghendershott/travis-racket.git&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;cat travis-racket/install-racket.sh | bash&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;export PATH="${RACKET_DIR}/bin:${PATH}"&lt;/span&gt;

&lt;span class="l l-Scalar l-Scalar-Plain"&gt;install&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;raco pkg install --deps search-auto frog&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;(It might be worth noting that Greg Hendershott &lt;em&gt;also&lt;/em&gt; maintains the repository that contains the above Travis build script!)&lt;/p&gt;

&lt;p&gt;Finally, in my case, I wasn&amp;rsquo;t deploying to a project-specific GitHub page. Instead, I wanted to deploy to my user page, which uses &lt;code&gt;master&lt;/code&gt;, not &lt;code&gt;gh-pages&lt;/code&gt;. Obviously, I didn&amp;rsquo;t want Travis running on my &lt;code&gt;master&lt;/code&gt; branch, since it would be deploying to that, so I added a branch whitelist:&lt;/p&gt;

&lt;div class="brush: yaml"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;branches&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="l l-Scalar l-Scalar-Plain"&gt;only&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;source&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;All that was left to do was to write up the actual deployment script to be used by Travis. Based on the one provided in the above Gist, mine looked like this:&lt;/p&gt;

&lt;div class="brush: bash"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#!/bin/bash&lt;/span&gt;
&lt;span class="nb"&gt;set&lt;/span&gt; -ev &lt;span class="c1"&gt;# exit with nonzero exit code if anything fails&lt;/span&gt;

&lt;span class="c1"&gt;# clear the output directory&lt;/span&gt;
rm -rf out &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="nb"&gt;exit&lt;/span&gt; 0&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;# build the blog files + install pygments for highlighting support&lt;/span&gt;
npm install
npm run build
pip install pygments
raco frog --build

&lt;span class="c1"&gt;# go to the out directory and create a *new* Git repo&lt;/span&gt;
&lt;span class="nb"&gt;cd&lt;/span&gt; out
git init

&lt;span class="c1"&gt;# inside this git repo we&amp;#39;ll pretend to be a new user&lt;/span&gt;
git config user.name &lt;span class="s2"&gt;"Travis CI"&lt;/span&gt;
git config user.email &lt;span class="s2"&gt;"&amp;lt;your@email.here&amp;gt;"&lt;/span&gt;

&lt;span class="c1"&gt;# The first and only commit to this new Git repo contains all the&lt;/span&gt;
&lt;span class="c1"&gt;# files present with the commit message "Deploy to GitHub Pages".&lt;/span&gt;
git add .
git commit -m &lt;span class="s2"&gt;"Deploy to GitHub Pages"&lt;/span&gt;

&lt;span class="c1"&gt;# Force push from the current repo&amp;#39;s master branch to the remote&lt;/span&gt;
&lt;span class="c1"&gt;# repo. (All previous history on the branch will be lost, since we are&lt;/span&gt;
&lt;span class="c1"&gt;# overwriting it.) We redirect any output to /dev/null to hide any sensitive&lt;/span&gt;
&lt;span class="c1"&gt;# credential data that might otherwise be exposed.&lt;/span&gt;
git push --force --quiet &lt;span class="s2"&gt;"https://&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;GH_TOKEN&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;@&lt;/span&gt;&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;GH_REF&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt; master &amp;gt; /dev/null 2&amp;gt;&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;1
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;For reference, my final &lt;code&gt;.travis.yml&lt;/code&gt; looked like this:&lt;/p&gt;

&lt;div class="brush: yaml"&gt;
 &lt;div class="source"&gt;
  &lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="l l-Scalar l-Scalar-Plain"&gt;language&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;python&lt;/span&gt;
&lt;span class="l l-Scalar l-Scalar-Plain"&gt;python&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3.4&amp;#39;&lt;/span&gt;

&lt;span class="l l-Scalar l-Scalar-Plain"&gt;branches&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="l l-Scalar l-Scalar-Plain"&gt;only&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;source&lt;/span&gt;

&lt;span class="l l-Scalar l-Scalar-Plain"&gt;env&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="l l-Scalar l-Scalar-Plain"&gt;global&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;GH_REF&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;github.com/lexi-lambda/lexi-lambda.github.io.git&amp;#39;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;secure&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;&amp;lt;long secure token...&amp;gt;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;RACKET_DIR&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;~/racket&amp;#39;&lt;/span&gt;
  &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;RACKET_VERSION&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;6.2&amp;#39;&lt;/span&gt;

&lt;span class="l l-Scalar l-Scalar-Plain"&gt;before_install&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;git clone https://github.com/greghendershott/travis-racket.git&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;cat travis-racket/install-racket.sh | bash&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;export PATH="${RACKET_DIR}/bin:${PATH}"&lt;/span&gt;

&lt;span class="l l-Scalar l-Scalar-Plain"&gt;install&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;raco pkg install --deps search-auto frog&lt;/span&gt;

&lt;span class="l l-Scalar l-Scalar-Plain"&gt;script&lt;/span&gt;&lt;span class="p p-Indicator"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;bash ./deploy.sh&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;That&amp;rsquo;s it! Now I have a working blog that I can publish just by pushing to the &lt;code&gt;source&lt;/code&gt; branch on GitHub.&lt;/p&gt;</description></item></channel></rss>